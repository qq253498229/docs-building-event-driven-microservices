= 第 15 章 测试事件驱动型微服务

测试事件驱动型微服务的一大优点是它们非常模块化。服务的输入由事件流或来自“请求–响应”API 的请求所提供。状态被物化到服务自己的独立的状态存储，输出事件则被写入服务的输出流中。微服务的“小”和“目标明确”的特性使得它们比大而复杂的服务更易于测试。这种微服务要移动的部件较少，处理 I/O 和状态的方法相对标准，并且有很多机会与其他微服务复用测试工具。本章涵盖测试原则和策略，包括单元测试、集成测试和性能测试。

[#_15_1_通用测试原则]
== 15.1 通用测试原则

事件驱动型微服务会共享所有应用程序都通用的测试最佳实践。功能性测试，比如单元测试、集成测试、系统测试和回归测试，可以确保微服务做它应该做的事情。非功能性测试，比如性能测试、负载测试、压力测试和恢复测试，能够确保微服务在各种环境场景中按预期运行。

现在，在进一步讨论之前需要注意，本章是关于测试原理和操作方法的更广泛内容的一部分。毕竟，关于测试的图书、博客和文档有很多，我当然不能像它们那样涵盖测试的内容。本章主要介绍特定于事件驱动的测试方法和原则，以及它们如何集成到总体测试蓝图中。请参考关于特定语言测试框架和测试最佳实践的资料，以补充本章的内容。

[#_15_2_单元测试拓扑函数]
== 15.2 单元测试拓扑函数

单元测试用于测试应用程序代码中的最小片段以确保它们正常工作。这些小型测试单元为编写更大、更全面的测试，以测试应用程序的更高级功能提供了基础。事件驱动拓扑通常会将转换、聚合、映射和归约函数应用于事件，这些函数是单元测试的理想候选函数。

image:image3.png[image,width=40,height=46]
请确保为每个函数测试边界条件，比如 null 和最大值等。

[#_15_2_1_无状态的函数]
=== 15.2.1 无状态的函数

无状态的函数不需要来自前面的函数调用的持久化状态，所以可以很容易地进行独立测试。以下代码显示了一个 EDM 拓扑的示例，该示例类似于在 map reduce 类型的框架中的拓扑。

----
myInputStream
    .filter(myFilterFunction)
    .map(myMapFunction)
    .to(outputStream)
----

myMapFunction 和 myFilterFunction 是独立的函数，它们都不保存状态。每个函数都应该进行单元测试，以确保其正确地处理预期范围内的输入数据，特别是边界情况。

[#_15_2_2_有状态的函数]
=== 15.2.2 有状态的函数

有状态的函数的测试通常会比无状态的函数的测试更复杂。状态会随着时间和输入事件而变化，所以必须仔细测试所有必要的有状态的边缘情况。有状态的单元测试还要求持久化状态（无论是模拟外部数据存储还是临时内部数据存储）在测试期间可用。

下面是一个在基础的生产者–消费者实现中可发现的有状态的聚合函数例子。

----
public Long addValueToAggregation(String key, Long eventValue) {
    //数据存储需要能够用于单元测试环境
    Long storedValue = datastore.getOrElse(key, 0L);
    //对值加总并将其存回状态存储中
    Long sum = storedValue + eventValue;
    datastore.upsert(key, sum);
    return sum;
}
----

该函数用于对每个键的 eventValue 求和。模拟端点是在测试期间提供数据存储的可靠实现的一种方法。另一种方法是创建一个本地可用的数据存储版本，不过这更类似于集成测试，稍后将详细介绍。无论是哪种情况，都必须仔细考虑此数据存储需要做什么，以及它与运行时使用的实际实现的关系。模拟的方法通常都能工作得很好，因为它允许进行非常高性能的单元测试，而不必为构建数据存储的完整实现而增加开销。

[#_15_3_测试拓扑]
== 15.3 测试拓扑

功能完整的轻量级框架和重量级框架通常提供了本地测试整个拓扑的方法。如果你的框架没有提供，那么用户和贡献者社区可能已经创建了提供此功能的第三方选项（这是选择具有强大社区性框架的另一个原因）。例如，除了提供内置的 MemoryStream 类用于对流输入和输出进行细粒度控制，Apache Spark 还有两个不同的第三方单元测试选项，即 StreamingSuiteBase 和 spark-fast-tests。Apache Flink 提供了自己的拓扑测试选项，Apache Beam 也是如此。对于轻量级的流框架，Kafka Streams 提供了使用TopologyTestDriver 测试拓扑的方法，它模拟了框架的功能，而无须设置整个事件代理。

拓扑测试比单个单元测试更复杂，并且要执行特定业务逻辑的整个拓扑。你可以将你的拓扑想象成由多个可移动部件组成的单个、大型、复杂的函数。拓扑测试框架让你可以完全控制将哪些事件生产到输入流以及何时创建这些事件。你既可以生成带特定值的事件、乱序的事件、包含非法时间戳的事件，或者包含非法数据的事件，也可以生成用来测试边界逻辑的事件。这样才能确保基于时间的聚合、事件调度和有状态函数等操作按预期执行。

例如，考虑下面这个 MapReduce 类型的拓扑定义。

----
myInputStream
    .map(myMapFunction)
    .groupByKey()
    .reduce(myReduceFunction)
----

在这个拓扑中，消费的事件通过变量 myInputStream 表示。应用了一个映射函数，然后根据键将结果分组在一起，最后每个键简化为一个事件。虽然可以为 myMapFunction 和 myReduceFunction 实现单元测试，但它们不能轻松地再现 map、groupByKey 和 reduce 的框架操作，因为这些操作（以及其他操作）是框架的固有部分。

这就是拓扑测试发挥作用的地方。每个流框架对测试拓扑有不同程度的支持，你必须将可用的选项暴露出来。这些测试框架不需要你创建一个事件代理来维持输入事件或者搭建重量级框架集群来进行处理。

[#_15_4_测试schema演化和兼容性]
== 15.4 测试schema演化和兼容性

根据任一事件流 schema 演化规则（参见 3.1.3 节），要确保所有输出 schema 与之前的 schema 兼容，你可以从 schema 注册表中提取 schema，并在代码提交过程中执行演化规则检查。一些应用程序可能使用 schema 生成工具在编译时从代码中定义的类或结构自动生成 schema，从而可自动与以前版本进行比较。

[#_15_5_事件驱动型微服务的集成测试]
== 15.5 事件驱动型微服务的集成测试

微服务集成测试有两种主要形式：本地集成测试和远程集成测试。本地集成测试指在生产环境的本地化副本上执行的测试，远程集成测试指在本地系统外部的环境中执行的微服务。这两种形式都有许多优点和缺点，稍后将对此进行探讨。

第三种形式是一种混合选项，其中微服务及其测试环境的某些部分在本地托管或执行，其他部分在远程执行。由于技术上不可能评估这种混合模式的所有组合和排列，因此本书只关注两种主要情况，如果有不同的需求，则由你自己决定。

在本章的剩余部分，你应该记住以下几个首要问题。

* 你希望从集成测试中得到什么？是不是验证“这个能运行吗”？抑或这是生产数据的冒烟测试吗？还是有更多复杂的工作流需要测试和验证？
* 你的微服务是否需要支持从输入流时间的最开始位置重新启动，例如由于错误而导致的数据完全丢失或再处理？如果是这样，那么为测试这个功能是否按预期工作，你需要知道些什么？你可能还需要验证输入事件流是否能够支持此需求。
* 你需要什么数据来确定成功或失败？手动编制的事件数据是否足够？需要以编程方式创建吗？需要真实的生产数据吗？如果是，需要多少？
* 你是否有任何性能、负载、吞吐量或伸缩方面的问题需要测试？
* 你将如何确保构建的每个微服务不需要一个完整的自建集成测试解决方案？

接下来的内容将有助于你了解一些可用的选项，以便对这些问题给出自己的答案。

[#_15_6_本地集成测试]
== 15.6 本地集成测试

本地集成测试允许进行大范围的功能性测试和非功能性测试。测试的形式是使用生产环境的本地副本，其中微服务会部署在上面。这意味着至少要创建一个事件代理、schema 注册表、所有特定于微服务的数据存储、微服务本身以及任何所需的处理框架（比如当你使用重量级框架或 FaaS 时）。你还可以引入容器化、日志记录，甚至 CMS，但它们与微服务的业务逻辑没有严格的关系，因此不是绝对必要的。

构建自己的本地可控环境的最大好处是可以独立地控制每个系统。你可以以编程方式创建在实际生产环境会出现的场景，例如间歇性故障、乱序事件和网络访问丢失。你还可以测试框架与业务逻辑的集成。本地集成测试还提供了测试水平伸缩的基本功能的方法，特别是在涉及协同分区和状态的情况下。

本地集成测试的另一个显著好处是，你可以在相同的工作流中同时有效地测试事件驱动逻辑和“请求–响应”逻辑。你可以完全控制事件何时注入输入流中，并且在处理事件之前、期间或之后的任何时候发出请求。为了测试你的微服务，将“请求–响应”API 看作另一个事件源可能会有所帮助。

下面来看看每个系统部件能提供的一些选项。

事件代理

* 创建和删除事件流；
* 对输入流应用选择性事件排序以执行基于时间的逻辑、模拟无序事件和上游生产者故障；
* 修改分区数；
* 引发代理故障并恢复；
* 引发事件流可用性故障并恢复。

schema 注册表

* 发布给定事件流的兼容演化的 schema，并使用它们生成输入事件；
* 引发故障并恢复。

数据存储

* 对现有的表进行 schema 变更（如果适用的话）；
* 对存储的过程进行变更（如果适用的话）；
* 当应用程序实例数被修改时重建内部状态（如果适用的话）；
* 引发故障并恢复。

处理框架（如果适用的话）

应用程序和处理框架通常是交织在一起的，你可能需要为测试提供完整的框架实现，就像 FaaS 和重量级框架解决方案一样。框架提供的功能如下：

* 通过内部事件流（轻量级）或洗牌机制（重量级）进行洗牌，以确保正确的协同分区和数据局部性；
* 检查点、故障以及从检查点恢复；
* 引发工作者实例故障以模拟丢失一个应用程序实例（重量级框架）。

应用程序

应用程序级别的控制主要涉及管理在任何给定时间运行的实例数。集成测试应该包含伸缩实例数（动态地，如果支持的话），以确保：

* 再平衡的正常执行；
* 从检查点或变更日志流恢复内部状态，并保留了数据局部性；
* 外部状态访问不受影响；
* “请求–响应”访问有状态的数据不会受应用程序实例数改变的影响。

对所有这些系统进行完全控制的目的是确保微服务在各种故障模式、不利条件和不同处理能力下仍能按预期工作。

执行本地集成测试有两种主要方式。第一种方式涉及嵌入测试库，这些库可以嵌入代码中。并不是所有微服务都适用这种方案，而且它们往往严重依赖于语言和框架支持。第二种方式涉及创建一个本地环境，其中安装了必要的组件，并且可以根据需要进行控制。下面先来看看这些方法，然后再研究依赖托管服务的测试微服务的方式。

[#_15_6_1_在测试代码的运行时内创建临时环境]
=== 15.6.1 在测试代码的运行时内创建临时环境

将测试库嵌入代码中是迄今为止最受限的选项，尽管它可以很好地工作，不过这取决于客户端、代理和框架编程语言的兼容性如何。在这种方法中，测试代码会在与应用程序相同的可执行文件中启动必要的组件。

例如，Kafka Streams 应用程序的测试代码会启动自己的 Kafka 代理、schema 注册表和微服务拓扑实例。然后，测试代码可以启动并停止拓扑实例、发布事件、等待响应、导致代理中断以及引发其他故障模式。一旦终止，所有组件都被终止，状态将被清除。考虑以下伪代码（为简洁起见，略过声明和实例化）。

----
broker.start(brokerUrl, brokerPort, ...);
schemaRegistry.start(schemaRegistryUrl, srPort, ...);
//微服务的第一个实例
topologyOne.start(brokerUrl, schemaRegistryUrl,
    inputStreamOne, inputStreamTwo ...);

//同一个微服务的第二个实例
topologyTwo.start(brokerUrl, schemaRegistryUrl,
    inputStream, inputStreamTwo, ...);

//发布一些测试数据到输入流1
producer.publish(inputStreamOne, ...);
//发布一些测试数据到输入流2
producer.publish(inputStreamTwo, ...);
//等一段时间。这不是最好的办法，但你能够理解
Thread.sleep(5000);

//现在模拟topologyOne发生故障
topologyOne.stop();

//检查输出主题的输出。是否符合预期？

event = consumer.consume(outputTopic, ...)

//如果没有其他测试则关闭剩余的组件
topologyTwo.stop()
schemaRegistry.stop()
broker.stop()

if (event ...) //验证消费者输出
    //如果正确则通过测试
else
    //测试不通过
----

Kafka Streams 是一个特别恰当的例子，因为它说明了这种方法的局限性。应用程序代码、代理和Confluent schema 注册表都是基于 JVM 的，因此你需要一个基于 JVM 的应用程序以编程方式控制同一运行时中的所有内容。其他开源的重量级框架也可以工作，尽管创建主实例和工作者实例需要一些额外的开销。请记住，由于这些重量级框架大部分也是基于 JVM 的，因此在撰写本书时，这种策略主要是一种只使用 JVM 的方法。虽然可以使用变通方法来测试非 JVM 应用程序，但这个过程并没有那么简单。

[#_15_6_2_在测试代码外部创建临时环境]
=== 15.6.2 在测试代码外部创建临时环境

设置环境以执行这些测试的一种方法是只需在本地安装和配置所有必需的系统。这是一种低开销的方法，特别是当你刚开始使用微服务时，但是如果每个团队成员都必须这样做，那么在他们每个人运行的版本略有不同的情况下，调试就会变得成本高昂且复杂。与大多数微服务一样，最好避免重复步骤，而是提供支持性工具以消除开销。

更灵活的方法是创建一个容器，其中安装并配置了所有必需的组件。所有想要以此方式测试应用程序的团队都可以使用这个容器。你可以维护一个开源贡献模型（即使是在组织内部），允许为所有团队添加修复、更新和新功能。这个模型非常灵活，可以与任何编程语言一起使用，不过与能够跟容器内部通信的可编程 API 一起使用要容易得多。轻量级处理框架示例如图 15-1 所示，其在容器内部创建了 schema 注册表、事件代理和必要的主题。微服务实例本身是在容器外部执行的，只需从其测试配置文件中引用代理和 schema 注册表的地址。

.图 15-1：使用容器化测试依赖项进行本地集成测试的轻量级微服务
image::image511.png[]

[#_15_6_3_使用mocking和模拟器方法集成托管服务]
=== 15.6.3 使用mocking和模拟器方法集成托管服务

本地集成测试环境可能也需要提供托管服务，比如托管的事件代理、重量级框架或 FaaS 平台。虽然一些托管服务有可运行的开源方案（比如开源的 Kafka），但不是所有的托管服务都能如此。例如，微软的Event Hubs、谷歌的 PubSub 和亚马逊的 Kinesis 都是专有且封闭的，无法下载完整的实现。在这种情况下，你所能做的就是使用这些公司或开源项目提供的模拟器、库或组件。

例如，谷歌的 PubSub 就有一个模拟器，其可以提供足够的本地测试功能，正如 LocalStack 提供的开源版本的 Kinesis（以及许多其他的亚马逊服务）一样。不幸的是，Microsoft Azure 的 Event Hubs 目前没有模拟器，也没有提供开源实现。然而，Azure Event Hub 客户端允许你使用 Apache Kafka 代替它，但并非所有功能都受支持。

FaaS 平台上的应用程序可以使用托管服务提供的本地测试库。谷歌云函数可以进行本地测试，亚马逊的Lambda 函数和 Microsoft Azure 的函数也可以进行本地测试。如第 9 章所述，开源解决方案OpenWhisk、OpenFaaS 和 Kubeless 提供了类似的测试机制，你可以通过 Web 搜索快速找到它们。这些方案使你可以在本地配置完整的 FaaS 环境，这样就可以在与生产环境尽可能类似的平台上进行测试了。

为使用重量级框架的应用程序搭建集成测试环境与为 FaaS 框架搭建集成测试环境很相似。它们都需要安装和配置框架，应用程序直接向框架提交处理作业。对于重量级框架，典型的单容器安装只需将主实例和工作者实例与事件代理和任何其他依赖项一起运行。当重量级框架搭建好之后，只需向主实例提交处理作业并等待输出事件流中的测试输出。图 15-2 展示了一个例子，其中整个依赖集已被容器化，以便在开发人员之间分发。

.图 15-2：使用容器化测试依赖项进行本地集成测试的重量级微服务
image::image512.png[]

[#_15_6_4_集成没有本地支持的远程服务]
=== 15.6.4 集成没有本地支持的远程服务

在生产中使用的一些服务可能根本没有任何可用的本地方案，这对开发和集成测试来说都是缺点。一个现成的例子是 Microsoft Azure 的 Event Hub，它没有任何模拟器。缺乏本地可用的实现意味着除了这些应用程序的集成测试环境外，还必须为每个开发人员提供远程环境。这也是界线开始模糊的地方，因为到目前为止的集成测试主要是指将单个应用程序实例隔离在一个一次性且易于管理的本地环境中。在这个场景中产生的开销可能是独立开发和集成测试工作的真正障碍，所以在继续下一步之前一定要仔细考虑它。

缓解此问题通常需要与基础架构团队密切协调，以确保可以通过访问控制独立地调配测试环境，或者创建一个供所有人使用的大型公共环境（如本章后面所述，这有其自身的问题）。开发人员必须将本地临时环境连接到远程资源，但这可能会产生安全问题。清理和管理远程的临时环境也会出现问题。应对这一挑战的方法很多，但这种情况可能带来的问题太大，无法在这里全面解决。

好消息是，很多大型封闭源代码服务供应商正在努力提供本地的开发和测试方案，因此先行者们迟早都会有可用的方案。同时，请谨慎选择服务，并考虑其是否提供本地开发和集成测试选项。

[#_15_7_完全远程集成测试]
== 15.7 完全远程集成测试

完全远程集成测试使你能够执行在本地环境中难以执行的特定测试。例如，性能和负载测试对于确保被测微服务实现其服务级别目标至关重要。事件处理吞吐量、“请求–响应”延迟、实例伸缩和故障恢复都可通过完全集成测试获得。

image:image3.png[image,width=40,height=46]
完全集成测试的目标是创建一个尽可能接近生产环境的环境，包括应用程序运行中的事件流、事件数据量、事件 schema 和“请求–响应”模式（如果适用的话）。

完全集成测试通常使用以下三种方式中的一种。使用临时集成环境，一旦完成测试就丢弃它；使用共享的测试环境，该环境在集成测试之间持续存在，并由多个团队使用；使用生产环境本身来进行测试。

[#_15_7_1_程序化创建临时集成测试环境]
=== 15.7.1 程序化创建临时集成测试环境

14.13 节研究了以程序化方式生成事件代理和计算资源管理器的优势。你可以使用这些工具来生成集成测试的临时环境。可以创建一组单独的代理以及单独保留的计算资源来运行测试中的容器化微服务。使用这种方法进行完全集成测试的另一个好处是，它会定期执行创建新代理和计算环境的过程。这确保了脚本中发生的任何中断或配置中的任何缺陷都将在下一次集成测试中暴露出来。

在新搭建的环境中，下一个问题是缺少事件流和事件数据。毫无疑问，它们对于测试微服务是至关重要的。你可以通过直接询问用户或使用工具访问微服务代码库中的配置文件来获取要创建的事件流名称。分区数必须反映生产系统的分区数，以确保正确执行微服务的伸缩、协同分区和再分区逻辑。

一旦创建了事件流，下一步就是填充事件。这可以通过使用生产数据、特别策划的测试数据集或特别的编程生成的数据来实现。

pass:[1. 填充来自生产环境的事件]

可以从生产集群复制事件到测试集群新创建的事件流中。这就是 14.13.3 节中描述的复制工具发挥作用的地方，因为可以使用相同的工具从生产环境中复制特定的事件流并加载事件。你必须说明可能阻止获取生产数据的任何安全和访问限制。

优点::

* 它准确反映了生产数据。
* 可以根据需要复制任意多或少的事件。
* 完全隔离的环境可以防止其他正在测试的微服务无意中影响你的测试。

缺点::

* 复制数据可能会影响生产性能，除非你已经充分规划并确立了代理的限额。
* 可能需要复制大量的数据，对长生命周期的实体来说更是如此。
* 你必须对包含敏感信息的事件流负责。
* 需要大量的投入来简化创建和复制过程，以减少使用障碍。
* 可能会暴露敏感的生产事件。

pass:[2. 填充来自规划好的测试源的事件]

规划好的事件让你可以在集成测试中使用具有特定属性、值以及与其他事件有关系的事件。这些事件需要存储在稳定且安全的地方，以使它们不会被意外或不经意地覆盖、破坏或丢失。此策略通常用于单个共享测试环境（稍后将详细介绍），但你也可以通过将事件从持久数据存储加载到用户指定的流中来应用它，这类似于从生产环境中复制事件。

优点::

* 涉及较小的数据集。
* 经过仔细的规划来确保有特定的值和关系。
* 对生产环境没有影响。

缺点::

* 要维护的开销很大。
* 数据会变过时。
* 必须处理新的事件流。
* 必须处理 schema 变更。
* 较少使用的事件流可能不可用。

虽然这些缺点中有许多可以通过严格的操作流程来缓解，但这种策略往往最终会变成跟组织中的文档化倾向一样的形式。本来是令人满意的，但会变得过时、不一定相关，并且似乎总是比其他工作的优先级低。

pass:[3. 使用 schema 创建模拟的事件]

程序化创建模拟的事件是另一种填充事件流的方法。你可以从 schema 注册表中获取 schema 并根据schema 定义生成事件。甚至可以获取较旧版本的 schema 并为其生成事件。

这种方法的复杂性来自要确保有与其他事件具有适当关系的事件，特别是如果有任何服务正在进行流之间的联结或在进行跨不同类型的事件的聚合。将多个事件联结在一起的微服务需要创建具有能匹配主键/外键的事件，才能正确地运行服务的联结逻辑。虽然这通常不是一个重要的问题（特别是因为微服务代码表达了业务逻辑所需的关系），但它确实需要这些数据的创建者来确保其范围正确，并且所有数据都属于预期的范围和值。

优点::

* 不需要生产集群来提供任何数据，也不会对生产性能有任何副作用。
* 你可以使用模糊化工具来创建事件数据、测试边界条件以及其他潜在的格式错误和半成品的格式字段。
* 你可以创建在生产数据中没有的特定的测试用例，以确保覆盖边界情况。
* 使你可以利用第三方工具（如 Confluent Avro）来程序化地创建测试数据。

缺点::

* 与其他方案相比需要花费更多精力来创建有关系的数据。
* 与生产环境中分布的数据相比，创建的数据仍然不是完全精准的。例如，由于模拟数据中没有体现键的分布，其可能跟生产数据的数据量存在严重差异。
* 创建的数据不能准确地表示某些字段。例如，以特定方式解析字符串字段的业务操作在使用创建的测试数据时可以通过，但在使用生产数据的子集时会失败。

[#_15_7_2_使用共享环境进行测试]
=== 15.7.2 使用共享环境进行测试

另一个方案是创建一个单一的测试环境，其中包含一个共享的事件流池，所有的事件流都驻留在同一个事件代理中。这些流由表示生产数据子集的测试数据或前面所讨论的精心编制的测试数据填充。此方案提供了较低开销的测试环境，但将事件流和数据的管理工作转移到了应用程序开发人员身上。

优点::

* 很容易启动。
* 只需维护一个测试环境的基础设施。
* 与生产环境负载隔离。

缺点::

* 受制于“公地悲剧”。零碎和废弃的事件流会使你很难分辨哪些流对测试输入有效，哪些流只是以前未清理的测试的输出。
* 测试中的系统没有得到必要的隔离。例如，同时运行大规模性能测试的服务会影响彼此的结果。
* 不兼容的事件可能会生成到其他服务的输入事件流中。
* 事件流数据不可避免地变得过时，必须用较新的事件更新。
* 不能准确地表示在生产环境中出现的事件的范围。

image:image5.png[image,width=47,height=44]
就可用性而言，这种策略是最糟糕的选择，因为事件代理最终会成为混乱的事件流和损坏的数据的垃圾场。

在使用这种方案时，要做到与其他应用程序测试隔离是很难的，特别是当一个微服务的输出流是另一个微服务的输入流时。谨慎管理的数据流、严格的命名约定以及对写入事件流的限制有助于缓解这些缺点，但环境维护人员和用户需要勤勉工作并遵守纪律。

[#_15_7_3_使用生产环境进行测试]
=== 15.7.3 使用生产环境进行测试

你也可以在生产环境中测试微服务。微服务可以运转起来、从输入事件流中消费、应用业务逻辑并产生输出。最常见的方法是让微服务使用自己指定的输出事件流和状态存储，这样就不会影响现有的生产系统。当一个微服务的旧版本与测试中的新版本同时运行时，这一点尤为重要。

优点::

* 你能完全访问生产事件。
* 其利用生产环境的安全模型来确保遵循正确的访问协议。
* 非常适用于应用程序的冒烟测试。
* 不需要维护单独的测试环境。

缺点::

* 有影响生产环境功能的风险，特别是当负载很高时。不适用于负载和性能测试。
* 必须仔细清除在测试期间创建的资源，比如事件流、消费者组、访问控制权限和状态存储。这类似于共享临时环境方案的要求。
* 需要工具支持来保证处于测试中的微服务和事件流与“真正的生产”微服务隔离，特别是当要执行长期测试时。这包括用于管理和部署微服务的资源，因为生产环境中的每个观察者都必须能够识别哪些服务是真正的生产服务，哪些服务是正在测试的服务。

[#_15_8_选择你的完全远程集成测试策略]
== 15.8 选择你的完全远程集成测试策略

微服务模块化的好处在于，不必只选择一种方法来执行测试。可以根据需要使用任一方案，为其他项目切换到不同的方案，并随着需求的变化更新测试方法。对多集群事件代理的支持工具和事件复制功能的投资将在很大程度上决定你的测试方案。

如果你几乎没有支持性工具，那么很可能会采用一个单一且共享的测试事件代理，其中包含由各种团队和系统生成的事件流。你可能会看到可以用于测试的“好”事件流和后缀为“-testing-01”“-testing-02”“-testing-02-final”以及“-testing-02-final-v2”的事件流的混合。事件数据的可靠性、及时性以及 schema 的正确性都是不可保证的。部落知识虽然扮演着重要的角色，但它很难确保你的测试能充分反映服务在生产环境中的表现。此外，要让临时集群持续运行，并确保其支持性能测试、加载大数据集并提供永久的事件存储，所需的成本将很高。

通过对工具建设的适当投入，每个微服务可以建立自己的专用集群、用事件流填充集群、将一些生产数据复制到集群中并在与生产环境几乎相同的环境中运行测试。一旦测试完成，集群就可以被销毁，这样就消除了原本会留在共享集群中的测试制品。进入这一阶段的开销是巨大的，但是这个投入获得了多集群工作、冗余和灾难恢复的方案，而这些方案很难通过其他方式获得（更多详细信息，请参阅第 14 章）。

并不是说单一的共享测试集群本身就不好。谨慎地标记干净可靠的源代码流是很重要的，就像删除未使用的测试制品一样。具体且明确的职责可以让生产事件数据的团队把临时事件数据的可靠性管理好。团队还必须协调性能和负载测试，以确保它们不会影响彼此的结果。随着多集群和事件复制工具的不断改进，团队可以迁移到自己动态创建的测试集群中。

[#_15_9_小结]
== 15.9 小结

事件驱动型微服务主要从事件流中获取其输入数据。可以通过多种方式创建和填充这些流，包括从生产环境中复制数据、管理特定的数据集以及基于 schema 自动生成事件。每种方法都有自己的优点和缺点，但它们都依赖于支持性工具来创建、填充和管理这些事件流。

建立测试微服务的环境应该是一项协作性工作。毫无疑问，你组织中的其他开发人员和工程师将受益于一个通用的测试平台，因此应该考虑投资于工具以简化测试过程。程序化的环境配置（包括事件流的填充）可以显著减少为每个被测微服务设置环境的开销。

当对工具的投入较低时，单一的共享测试环境是一种常用的策略。权衡的结果是在管理事件数据、确保有效性和澄清所有权方面增加了难度。一次性环境是更好的选择，因为它们为测试中的服务提供了隔离，并减少了由多租户问题引起的风险和缺点。这些方案往往需要在常用的支持工具上进行更多的投入，但从长远来看可以节省大量的时间和精力。另外一个好处是，使用程序化环境配置和事件复制工具可以更好地为组织做好灾难恢复的准备。
