= 第 10 章 基础的生产者和消费者微服务

基础的生产者和消费者（basic producer and consumer，BPC）微服务从一个或多个事件流中摄取事件，应用必要的转换逻辑或业务逻辑，然后向输出事件流发出必要的事件。同步的“请求–响应”I/O 也可能是此工作流中的一部分，但这个主题将在第 13 章中进行更详细的介绍。本章会聚焦于事件驱动部分。

BPC 微服务的特征是使用了基础的消费者客户端和生产者客户端。基础的消费者客户端不涉及任何事件调度、水位、物化机制、变更日志或水平伸缩带本地状态存储的处理实例。这些功能通常只属于功能更全面的框架，第 11 章和第 12 章将更深入地讨论这些框架。虽然你也可以开发自己的库来实现这些功能，但这远远超出了本章所要介绍的内容范围。因此，你必须仔细考虑 BPC 模式是否能够满足业务需求。

可以使用最常用的语言来实现生产者客户端和消费者客户端，从而降低启用事件驱动型微服务时的认知开销。一个微服务应用程序的代码包含了界限上下文的完整工作流，这使微服务的职责更聚焦并易于理解。工作流还可以轻松地包装到一个或多个容器中（取决于实现的复杂性），然后可以使用微服务的容器管理解决方案部署和执行这些容器。

[#_10_1_bpc的适用场合]
== 10.1 BPC的适用场合

尽管缺少全能型框架组件的大部分能力，但 BPC 微服务可以满足广泛的业务需求。BPC 既能轻松实现像无状态转换这样的简单模式，也能实现不需要确定性事件调度的有状态模式。

在 BPC 实现中，外部状态存储比内部状态存储更常被使用，因为在没有采用全能型流框架的情况下，在多实例之间伸缩本地状态和从实例故障中恢复是很困难的。外部状态存储可以为多个微服务实例提供统一的访问以及数据备份和恢复机制。

下面来看几个较好的 BPC 用例。

[#_10_1_1_集成现有遗留系统]
=== 10.1.1 集成现有遗留系统

通过将生产者/消费者客户端集成到代码库中，遗留系统可以参与到事件驱动架构中来。这种集成通常在采用事件驱动型微服务的早期阶段就开始了，甚至可能是将遗留系统引导到事件驱动生态系统的策略之一（参见第 4 章）。遗留系统按要求向事件代理的单一事实来源生产自己的数据，然后从其他事件流中消费它们需要的所有事件。

在某些场景中，想安全地修改遗留系统的代码库以让其具有生产和消费事件的能力是很困难的。边车（sidecar）模式特别适用于解决此类问题，因为它无须影响源代码库就能获得一些事件驱动能力。

示例：边车模式

电子商务商店有一个前端界面，用于显示其所包含的所有库存和产品数据。以前，前端服务通过使用定时批处理作业从只读的从属数据存储中同步所有数据，如图 10-1 所示。

.图 10-1：单体服务之间的定时批处理作业
image::image190.png[]

现在有了两个事件流，一个包含产品信息，另一个包含产品库存水平。你可以使用“边车”来将数据落地到数据存储中，BPC 在其中消费事件并将它们插入相关的数据集中。前端服务无须更改任何系统代码就可获得近乎实时的产品更新数据，如图 10-2 所示。

.图 10-2：使用边车将数据插入前端状态存储中
image::image191.png[]

边车驻留于自己的容器内，但必须是前端服务的单独可部署部分。你必须执行额外的测试以确保集成的边车按预期运行。边车模式使得你无须对遗留代码库做出重大变更就能向系统添加新功能。

[#_10_1_2_不依赖于事件顺序的有状态的业务逻辑]
=== 10.1.2 不依赖于事件顺序的有状态的业务逻辑

许多业务流程对事件到达的顺序没有任何要求，但是所有必要的事件最终都要到达。这被称为浇注模式（gating pattern），而 BPC 实现很适用于该模式。

示例：图书出版

假如你现在就职于一家图书出版社，在准备将图书发送给印刷厂之前必须完成以下 3 件事。这些事件发生的顺序并不重要，重要的是在将图书发送给印刷厂之前每个事件都必须完成。

内容::

必须已经编写完了图书内容。

封面::

必须设计好了图书的封面。

定价::

必须根据地区和格式设置好了价格。

每个事件流都扮演着逻辑驱动器的角色。当一个新事件到达任意一个事件流时，它首先要被物化到合适的表里，接着要查找其他所有表以判断其他事件是否已存在。图 10-3 展示了一个例子。

.图 10-3：浇注模式下的图书出版准备工作流
image::image192.png[]

在本例中，以 ISBN 0010 结尾的图书已经发布到输出图书事件流中。同时，以 ISBN 0011 结尾的图书目前正在等待封面，而且还没有发布到输出流中。

image:image3.png[image,width=40,height=46]
在浇注模式中也可能需要人工审批流程。13.5 节会进行更详细的介绍。

[#_10_1_3_当数据层完成大部分工作时]
=== 10.1.3 当数据层完成大部分工作时

当底层的数据层执行了大部分业务逻辑时（比如地理数据存储、自由文本搜索、机器学习、AI 和神经网络应用程序），BPC 也是一种适用的方法。以一家电子商务公司为例，其接收从网站上爬取下来的新产品并使用 BPC 微服务进行分类，而它的后端数据层是经过批量训练的机器学习分类程序。或者，诸如打开应用程序之类的用户行为事件可以与地理空间数据存储相关联，以确定最近的零售商来显示其广告。在这些场景中，事件处理的复杂性完全转移到了底层数据层，生产者和消费者组件仅仅简单实现了集成机制。

[#_10_1_4_处理层和数据层独立伸缩]
=== 10.1.4 处理层和数据层独立伸缩

微服务的处理需求和数据存储需求并不总是线性相关的。例如，微服务必须处理的事件量可能随时间而变化。一种常见的负荷模式（包含在下面的示例中）反映了当地居民的睡眠/清醒周期，其白天活动强度高，晚上活动量很低。

示例：对事件数据进行聚合以了解用户参与情况

考虑将用户行为事件聚合为 24 小时会话的场景。这些会话数据用于确定哪些产品是最近最受欢迎的，并反过来用于推动销售广告。一旦 24 小时聚合会话完成，就会从数据存储中刷出结果数据并发送到输出事件流，从而释放数据存储空间。每个用户都在外部数据存储中维护一份聚合信息，如表 10-1 所示。

表 10-1：对事件数据进行聚合

|===
|键 |值
|userId,timestamp
|List(productId)
|===

服务的处理需求会随着使用产品的用户的睡眠/清醒周期而变化。在晚上，当大多数用户处于睡眠状态时，执行聚合操作所需要的处理能力与白天相比要小得多。为了节省处理能力方面的费用，要在夜间对服务进行缩容。

分区分配器可以将输入事件流分区重新分配给单个处理实例，因为单个实例也足以应对所有用户事件的消费和处理。请注意，尽管事件量很少，但潜在用户的领域范围会保持不变，因此该服务需要能够访问所有用户聚合数据。对处理进行缩容不会影响服务必须保持的状态数量。

白天，可以上线更多的处理实例以处理增加的事件负载。在此场景中，数据存储的查询率也会增加，但是缓存、分区和批处理等有助于将负载保持在低于跟随处理需求线性增长所要求的值。

image:image3.png[image,width=40,height=46]
谷歌、亚马逊和微软等服务供应商提供了高度可伸缩的按读/写收费的数据存储，这非常适用于此模式。

[#_10_2_具有外部流处理的混合bpc应用程序]
== 10.2 具有外部流处理的混合BPC应用程序

BPC 微服务还可以利用外部流处理系统来完成本地可能难以完成的工作。这是一种混合的应用程序模式，业务逻辑分布在 BPC 和外部流处理框架之间。第 11 章要介绍的重量级框架是这方面的优秀候选，因为它们可以通过简单的集成提供大规模流处理。

BPC 实现可以让程序具备原本不具有的操作能力，同时仍然可以使用所有必要的原有语言特性和库。例如，你可以使用外部流处理框架执行跨多个事件流的复杂聚合操作，同时使用 BPC 微服务将结果填充到本地数据存储并提供“请求–响应”查询。

[#_示例使用外部流处理框架来联结事件流]
=== 示例：使用外部流处理框架来联结事件流

假设 BPC 服务需要使用流处理框架的联结能力（流处理框架擅长于联结物化事件流的大型集合）。外部流处理器可以简单地将事件流物化到表，并将具有相同键的行联结到一起。这个简单的联结操作如图 10-4 所示。

.图 10-4：流处理框架大规模执行的典型外包操作
image::image193.png[]

混合的 BPC 需要使用兼容的客户端来启用在外部事件流处理框架上的工作。这个客户端会把代码转换成框架的指令，框架本身会处理消费、联结并生成事件到联结的输出事件流中。这个设计将工作外包给了外部服务，外部服务会以事件流的形式返回结果。此类工作流如图 10-5 所示。

.图 10-5：一个混合的工作流展示了外部流处理应用程序通过中间事件流将结果发送回 BPC
image::image194.png[]

image:image3.png[image,width=40,height=46]
BPC 会实例化一个客户端来运行外部流处理工作。当 BPC 被终止时，外部流处理实例也应该被终止，以确保没有幽灵进程在继续运行。

这种模式的主要优点是，它解锁了你的服务原本不具备的流处理特性。这些特性是否可用受限于相应流处理客户端的语言，并非任何语言都支持所有功能。这种模式经常与轻量级和重量级框架一起使用，例如，它是基于 SQL 的流操作（比如 Confluent 的 KSQL 提供的那些）的主要用例之一。像这样的技术方案提供了一种增强 BPC 产品的方法，使它能够拥有原本没有的强大的流处理能力。

此种模式的主要缺点与复杂性的增加有关。测试应用程序会变得异常复杂，因为你还必须找到将外部流处理框架集成到测试环境中的方法（参见第 15 章）。调试和开发的复杂性也增加了，因为流框架的引入增加了移动部件的数量和潜在的缺陷。最后，处理微服务的界限上下文可能会变得更加复杂，因为你要确保可以轻易地管理混合应用程序的部署、回滚和操作。

[#_10_3_小结]
== 10.3 小结

BPC 模式简单而强大。它是许多无状态和有状态的事件驱动型微服务模式的基础。你可以使用 BPC 模式轻易地实现无状态的流和简单的有状态的应用程序。

BPC 模式也是灵活的。它能够与在数据存储层执行大部分业务工作的实现很好地匹配。你可以将它作为事件流和遗留系统之间的接口层，也可以使用外部流处理系统来增强其功能。

但是，由于其基本性质，它确实需要你开发相关的库以实现诸如简单状态物化、事件调度和基于时间戳的决策等机制。这些组件与第 11 章和第 12 章中介绍的产品有交集，因此你需要确定是进行自研开发，还是采用更多定制的解决方案。
