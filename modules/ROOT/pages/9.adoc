= 第 9 章 使用“函数即服务”的微服务

“ 函数即服务” （function-as-a-service ，FaaS ）是近些年越来越流行的一种“ 无服务端”（serverless）解决方案。FaaS 解决方案使个人能够构建、管理、部署和扩展应用程序功能，而无须管理基础设施开销。作为实现简单到中等复杂解决方案的一种手段，它们可以在事件驱动系统中提供重要的价值。

函数是当某些触发条件发生时执行的一串代码。函数启动、运行直到完成，然后在工作完成后终止。FaaS解决方案可以轻松地根据负载上下调整函数执行的数量，密切跟踪高度可变的负载。

把 FaaS 解决方案看作会定期失败的基础消费者/生产者实现可能会对你成功实施该方案有所帮助。函数在经过一段预先设定的时间后会终止，并且所有与之相关的连接和状态也会消失。当你设计函数时要记住这一点。

[#_9_1_设计基于函数的微服务解决方案]
== 9.1 设计基于函数的微服务解决方案

FaaS 解决方案包含了许多不同的函数，它们的操作总和构成了业务界限上下文的解决方案。创建基于函数的解决方案的方法有很多，远超过本章所能涵盖的内容，但是有一些通用的设计原则可以帮助你完成这个过程。

[#_9_1_1_确保界限上下文的严格的成员关系]
=== 9.1.1 确保界限上下文的严格的成员关系

构成解决方案的函数及内部事件流必须严格从属于某个界限上下文，这样函数和数据的所有者就相当明确了。组织在大规模实施微服务解决方案时，通常会围绕函数、服务和事件流出现归属问题。虽然许多微服务解决方案会 1∶1 地映射到界限上下文，但 n∶1 的映射并不少见，因为许多函数可能用于同一个界限上下文中。确定哪个函数属于哪个界限上下文是很重要的，因为函数的高度颗粒化可能会模糊这些界限。

维护使用函数方案的界限上下文的一些实践方法包括：

* 确保数据存储是私有的，与外部上下文隔离；
* 当要耦合其他上下文时，使用标准的“请求–响应”或事件驱动接口；
* 围绕“哪些函数属于哪些界限上下文”（函数对产品 1∶1 地映射）维护严格的元数据；
* 在映射到界限上下文的代码仓库中维护函数代码。

[#_9_1_2_只在完成处理之后提交偏移量]
=== 9.1.2 只在完成处理之后提交偏移量

偏移量会在函数启动时或函数完成处理时发生提交。对于给定的一个事件或一批事件，只在处理完成之后提交偏移量是 FaaS 的最佳实践。理解如何在基于函数的特定解决方案中处理偏移量很重要，下面来看看每种方法的含义。

pass:[1. 当函数启动时]

一旦要处理的一批事件已经传递到函数，就可以提交偏移量了。这种简单的方法被用于许多 FaaS 框架中，这些框架依赖于自身的重试机制和告警来减少重复的失败处理。在编排模式中，调用其他函数的函数通常会采用该策略，因为它极大地简化了对事件处理情况的跟踪。

pass:[2. 当函数完成处理时]

函数完成处理后提交偏移量的方法与其他微服务实现提交偏移量的方法一致，无论它们是基于基础的生产者/消费者还是流处理框架。这个策略提供了最强的事件被“至少一次处理”的保证，并且与非FaaS 解决方案的偏移量管理策略是一样的。

但是，在处理完成之前提交偏移量可能会有问题。如果函数无法成功地处理事件，并且多次重试失败，那么数据可能会丢失。通常会将事件放入一个“死信”队列或简单地将其抛弃。许多基于函数的微服务对数据丢失并不敏感，而那些敏感的微服务不应该使用该策略。

[#_9_1_3_少即是多]
=== 9.1.3 少即是多

FaaS 框架的一个经常被推崇的特性是，它们可以很容易地编写一个函数并在多个服务中复用它。然而，遵循这种方法可能会导致一个高度分散的解决方案，这使得很难准确地辨别在界限上下文中发生了什么。此外，一个函数的所有权会变得模糊，并且当变更函数时会搞不清楚对其他微服务有什么副作用。虽然函数的版本管理有助于解决这个问题，但是当有多个产品要维护和升级不同的函数版本时，仍然会产生冲突。

FaaS 解决方案可以组合多个函数来解决界限上下文的业务需求，虽然这不是一个罕见或不好的做法，但较好的经验法则是，少量函数比许多细粒度函数更好。只对一个函数进行测试、调试和管理比对多个函数做同样的事情容易得多。

[#_9_2_选择faas供应商]
== 9.2 选择FaaS供应商

与事件代理和 CMS 一样，FaaS 框架可以选择免费的开源解决方案或者付费的第三方云供应商。使用自己的私有 CMS 进行微服务操作的组织，也可以从私有的 FaaS 解决方案中受益。有许多免费开源的选项，比如 OpenWhisk、OpenFaaS 和 Kubeless，它们可以使用已有的容器管理服务。Apache Pulsar 有自己内置的 FaaS 解决方案，可以与其事件代理配合运行。通过利用公共资源调配框架，你的 FaaS 解决方案可以与微服务解决方案保持一致。

Amazon Web Services（AWS）、Google Cloud Platform（GCP）和 Microsoft Azure 等第三方服务供应商也有自己的专有 FaaS 框架，每个框架都提供了吸引人的特性和功能，但仍然与其提供的专有事件代理紧密集成。这是一个严重的问题，因为当前这 3 家供应商都将其事件代理内的保留期限制为 7 天。云供应商和开源事件代理之间的集成方案虽然存在（比如 Kafka Connect），但可能需要额外的工作来搭建和管理。也就是说，如果你的组织已经使用了 AWS、GCP 和 Azure 的服务，那么开启这个体验的开销就很小。

[#_9_3_在函数之外构建微服务]
== 9.3 在函数之外构建微服务

无论你使用什么 FaaS 框架或事件代理，当采用基于函数的解决方案时，就必须考虑 4 个主要元素。

* 函数
* 输入事件流
* 触发逻辑
* 带元数据的错误处理和伸缩策略

FaaS 实现的第一个组件是函数本身。函数可以用 FaaS 框架所支持的任何代码来实现。

----
public int myfunction(Event[] events, Context context) {
    println ("hello world!");
    return 0;
}
----

events 参数包含了要处理的事件数组，每个事件包含 key、value、timestamp、offset 和 partition_id等字段。context 参数包含了关于函数及其上下文的信息，比如名字、事件流 ID 和函数的剩余寿命。

接下来，需要为函数写一些触发逻辑。下一节会更详细地介绍这方面的内容，但是现在，记住，一旦有新的事件到达函数订阅的其中一个事件流，就会触发函数执行。触发逻辑常常通过“函数触发映射表”与函数相关联，函数触发映射表通常隐藏在 FaaS 框架的幕后。以下是一个示例（参见表 9-1）。

表 9-1：函数触发映射表

|===
|函数|事件流|触发器|策略和元数据
|myFunction|myInputStream|onNewEvent|<...>
|===

可以看到，函数 myFunction 在新事件发布到 myInputStream 时被触发。你还会注意到，有一个名为“策略和元数据”的列，它有点儿包罗万象，包括以下配置。

* 消费者组
* 消费者属性，比如批量大小和批量窗口
* 重试和错误处理策略
* 伸缩策略

一旦建立了触发器、元数据和策略，函数就会准备处理到来的事件。当新的事件到达输入事件流时，FaaS框架会启动函数，向其传递一批事件，然后函数开始进行处理。一旦处理完成，函数会终止操作并等待更多事件到来。这是一个典型的事件流监听器模式的实现，下一节会进行更详细的介绍。

image:image3.png[image,width=40,height=46]
跟其他非 FaaS 微服务一样，每个基于函数的微服务实现都必须有自己独立的消费者组。

现在请记住，这只是成功触发和操作函数所需组件的逻辑表示。FaaS 框架的函数编码要求、函数管理和触发机制会根据供应商和实现的不同而变化，所以请务必参考 FaaS 框架的文档。

触发机制、事件消费、消费者偏移量、嵌套函数、故障以及至少一次事件处理之间也存在一些复杂的相互作用。这些是本章剩余内容要讨论的主题。

[#_9_4_冷启动和热启动]
== 9.4 冷启动和热启动

冷启动是函数在第一次启动或在足够长的不活动时间后启动时的默认状态。此时容器必须启动并加载代码、创建事件代理连接，并且建立所有跟外部资源的客户端连接。一旦所有元素都准备就绪，函数就处于一个“热”的状态并准备处理事件。“热”函数开始处理事件，在到期或完成处理时暂停并进入挂起状态。

大部分 FaaS 框架想要尽可能重用终止处理的函数。在许多情况下，处理稳定的事件流的函数会遇到超时到期并短暂终止，稍后由触发机制再次触发。挂起的实例可以简单地重用，如果与事件代理和任何状态存储的连接在此期间没有过期，则可以立即恢复处理。

[#_9_5_用触发器启动函数]
== 9.5 用触发器启动函数

触发器用于通知函数启动并开始处理。如接下来的内容所述，不同的 FaaS 框架支持的触发器会有所不同，但通常都有相同的分类。现在来看看有哪些信号可以用来启动函数，以及分别在什么时候可能需要使用它们。

[#_9_5_1_基于新事件触发事件流监听器]
=== 9.5.1 基于新事件触发：事件流监听器

当事件被发布到事件流中时可以触发函数。事件流监听触发器用预先定义好的消费者屏蔽了事件消费逻辑，这减少了开发者必须编写的代码量。事件以事件数组的形式直接发送给函数，它们会按照事件流中的顺序排列，如果消费来自队列的事件则是一串无序的事件。你可以创建事件流到函数的多个映射关系，比如一个函数可以从多个不同的流消费事件。

来自谷歌、微软和亚马逊的 FaaS 解决方案为其专用事件代理提供了此类触发器，但目前不支持直接从开源代理触发。此方法通常的结构如图 9-1 所示。

.图 9-1：集成了事件流监听器的 FaaS 框架
image::image182.png[]

相反，开源解决方案（如 OpenFaaS、Kubeless、Nuclio 等）为各种事件代理（如 Kafka、Pulsar 和NATS）提供了各种触发插件。例如，Apache Kafka Connect 允许你触发第三方 FaaS 框架的函数。由于Kafka Connect 运行在 FaaS 框架之外，因此最终只会作为一个事件流监听器的角色而存在，如图 9-2所示。

.图 9-2：Kafka Connect 提供的外部事件流监听器应用程序
image::image183.png[]

虽然前面的例子中没有展示，但是也可以将函数结果输出到它们自己的事件流中，不只是为了输出数据，也是为了跟踪函数是否成功调用。

同步触发器在函数处理完一批事件之后才会发出下一批事件。这对于保证处理顺序是相当重要的，并且受限于被处理的事件流的并行度。相反，异步触发可以发送多个事件到多个函数，每个函数在完成处理之后返回。但是，这将无法保证处理的顺序，并且只能用于处理顺序对业务逻辑不重要的场景。

在流监听触发器中，批量大小和批量窗口是需要考虑的两个重要属性。批量大小表明了发送给函数处理的事件的最大数量，批量窗口表明了等待额外事件的最长时间，而不是立即触发函数。这两个参数都用于确保在批记录中分配启动函数的开销，以降低启动成本。

由流监听触发器函数执行的示例代码如下所示。

----
public int myEventfunction(Event[] events, Context context) {
    for(Event event: events)
    try {
        println (event.key + ", " + event.value);
    } catch (Exception e) {
        println ("error printing " + event.toString);
    }
    //向FaaS框架表明批处理已经完成
    context.success();

    return 0;
}
----

image:image3.png[image,width=40,height=46]
与容器化的微服务类似，事件流监听器模式的触发器可以配置成从流的最新的偏移量、最早的偏移量或这两者之间的任何位置开始处理事件。

[#_9_5_2_基于消费者组的滞后度触发]
=== 9.5.2 基于消费者组的滞后度触发

消费者组的滞后度量是另一种触发函数的方法。可以通过定期轮询每个应用程序的消费者组的偏移量并计算当前消费者偏移量和流的头部偏移量的差值来消除滞后度（参见 14.10 节获取更多关于滞后度监控的内容）。虽然与流监听触发器类似，但滞后度监控也可以用于非 FaaS 微服务的扩缩容。

滞后度监控通常涉及计算并向所选择的监控框架上报滞后度量值。然后监控框架可以调用 FaaS 框架以通知其启动注册在该事件流上的函数。高滞后度值表明要启动多个函数实例来更快速地处理负载，而低滞后度值只需要一个函数实例来处理积压。可以一个微服务接一个微服务地定制滞后量和函数启动之间的关系，确保其符合 SLA。

与之前提到的事件流监听触发器最大的不同是，用滞后度触发的函数直到启动之后才开始消费事件。滞后度触发器启动的函数有更广的职责范围，包括建立与事件代理的客户端连接、消费事件和提交偏移量更新。这使得滞后度触发的函数与基础的生产者 / 消费者模式更为相似，尽管其使用寿命有限。下面的示例代码展示了这个工作流。

----
public int myLagConsumerfunction(Context context) {
    String consumerGroup = context.consumerGroup;
    String streamName = context.streamName;

    EventBrokerClient client = new EventBrokerClient(consumerGroup, ...);

    Event[] events = client.consumeBatch(streamName, ...);

    for(Event event: events) {
        //执行事件处理操作
        doWork(event);
    }
    //将偏移量提交回事件代理
    client.commitOffsets();

    //向FaaS框架表明函数已成功执行
    context.success();

    //返回，让滞后度触发系统知道函数已成功执行
    return 0;
}
----

消费者组和流名字作为上下文中的参数传递给了函数。创建客户端、消费并处理事件，然后向事件代理提交偏移量。函数将一个 success 结果报告给 FaaS 框架，然后返回。

如果该函数频繁地由滞后度监控器触发，则从上一次迭代开始到现在，它很有可能仍然是“热”的，而此时连接到事件代理客户端的开销可能就不是关键问题。当然，这依赖于客户端使用的超时时间和事件代理配置。对于较长时间不活动的情况，消费者组再平衡和客户端冷启动会略微减少一个函数实例可以处理的工作量。

[#_9_5_3_按调度表触发]
=== 9.5.3 按调度表触发

函数可以被安排成定期启动或者在特定日期时间启动。调度好的函数按指定的时间间隔启动，轮询源事件流中的新事件，并根据需要进行处理或关闭。轮询期应保持较小的值以保证 SLA，过于频繁的轮询会给FaaS 框架和事件代理带来不适当的负载。

基于时间触发器的客户端代码看起来与消费者组滞后触发器示例的客户端代码相同。

[#_9_5_4_使用网络钩子触发]
=== 9.5.4 使用网络钩子触发

函数也可以通过直接调用触发，允许与监控框架、调度程序和其他第三方应用程序进行自定义集成。

[#_9_5_5_触发资源事件]
=== 9.5.5 触发资源事件

更改资源也可能是一种触发源。例如，创建、更新或删除文件系统里的一个文件可以触发函数，对数据存储中的一行记录进行更新也可以触发函数。由于事件驱动型微服务领域中的大多数事件是通过事件流生成的，因此这种特定的资源触发器在大多数业务工作流中并不常用。但是，当你需要与 FTP 或其他文件服务提供的外部数据集成时，它会非常有用。

[#_9_6_用函数执行业务工作]
== 9.6 用函数执行业务工作

FaaS 方法尤其适用于需要灵活地按需进行资源调配的解决方案。简单型拓扑是可采用此方法的一个候选场景，而无状态拓扑、不需要对多个事件流进行确定性处理的拓扑以及伸缩范围非常广的拓扑（比如基于队列的处理）也都是适用的场景。任何对容量需求高度变化的产品都可以从 FaaS 解决方案中获益，因为FaaS 的水平伸缩能力和按需特性可以快速调配和释放计算资源。

当不考虑并发性和确定性时，FaaS 解决方案可以非常好地运行。但是，一旦要考虑确定性，就必须非常小心地确保事件流处理的正确性和一致性。与第 10 章将要介绍的基础消费者解决方案非常类似，FaaS解决方案要求你提供事件调度器以确保一致的处理结果。协同分区的数据一次只能由单个函数进行处理，这类似于功能齐全的轻量级框架和重量级框架只能使用单线程的情况。

[#_9_7_维持状态]
== 9.7 维持状态

由于函数的寿命很短，因此大多数基于 FaaS 的有状态的解决方案需要使用外部有状态的服务。部分原因是许多 FaaS 提供商的目标是提供快速、高度可扩展的处理能力单元，而不依赖于数据的位置。如果函数要获得之前操作得到的本地状态，那么当前操作就只能限定在与本地状态相同的节点上执行。这大大降低了 FaaS 供应商的灵活性，因此它们通常强制执行“无本地状态”策略，并要求所有有状态的内容都存储在执行者的外部。

如果函数是从“热”状态启动的，那么之前的本地状态可能还是存在的，但无法保证一直都是如此。就像其他所有客户端一样，连接到外部状态存储的函数需要创建到状态存储的连接并使用对应的 API。函数必须对状态进行显式的持久化和检索。

image:image3.png[image,width=40,height=46]
请确保对函数的状态采取严格的访问限制，杜绝来自其界限上下文外部的任何访问。

一些 FaaS 框架已经添加了持久的有状态的函数支持，比如 Microsoft Azure 的 Durable Functions，它抽象了显式的状态管理并允许你使用本地内存，该内存会自动持久化到外部状态存储上。这使得开发者无须针对函数的挂起和唤起来编写代码以显式地存储和检索状态。这大大简化了有状态的工作流的实现，并提供了跨函数实现的标准化状态管理的选项。

FaaS 框架会持续成长并包含新的特性。简单的状态管理是基于函数的解决方案中的一个普遍需求，因此请注意你选择的 FaaS 框架中的状态处理的进化情况。

[#_9_8_调用其他函数的函数]
== 9.8 调用其他函数的函数

函数通常用于执行其他函数，也可以用于编排和编制工作流。函数之间的通信可以通过事件、“请求–响应”调用或二者相结合异步地进行。这些选择在很大程度上取决于 FaaS 框架和界限上下文的问题空间。当实现多函数的解决方案时，通常采用编排和编制的设计模式。

image:image3.png[image,width=40,height=46]
为了避免乱序处理的问题，请确保完成了一个事件的所有处理之后才处理下一个事件。

[#_9_8_1_事件驱动通信模式]
=== 9.8.1 事件驱动通信模式

可以将函数的输出作为事件生产到事件流中供其他函数消费。一个界限上下文可能由许多函数和内部事件流组成，每个函数定义了不同的触发和伸缩逻辑。每个函数按照自己的处理速率消费事件、执行工作并生成输出。此类设计的例子如图 9-3 所示。

.图 9-3：包含多个函数的事件驱动型 FaaS 拓扑代表一个微服务
image::image184.png[]

在本例中，函数 A 独立于函数 B 和函数 C 的触发器而触发。事件流 2 和事件流 3 被认为是内部事件流，界限上下文之外的所有函数都无法访问它们的内容。每个函数都使用相同的消费者组从其源流消费事件，因为这些函数全都处于相同的界限上下文中。这确保了函数可以按与非 FaaS 型微服务一样的方式高效运行。

使用基于事件的通信模式有很多优点。拓扑里的每个函数都可以管理自己的消费者偏移量，在工作完成后进行偏移量提交。除了事件流处理之外，函数之间不需要协作。尽管图 9-3 展示的是基于编排的设计模式，但也可以使用编制模式。此外，事件处理过程中的失败不会导致数据丢失，因为事件是在事件代理中持久存储的，下一个函数实例可以方便地进行重新处理。

[#_9_8_2_直接调用模式]
=== 9.8.2 直接调用模式

在直接调用模式中，一个函数可以通过其代码直接调用其他函数。对其他函数的直接调用可以是异步的（这是一种“发射即不管”的方式）或是同步的（调用函数并等待返回值）。

pass:[1. 编排模式与异步的函数调用]

异步的直接调用引出了基于编排的 FaaS 解决方案。一个函数基于其业务逻辑简单地调用下一个函数，由下一个函数和 FaaS 框架来处理下一步操作，包括任何失败或错误处理。异步的直接调用函数拓扑是一种简单的将函数调用链接到一起的方式。图 9-4 展示了一个例子。

.图 9-4：一个界限上下文里的编排型异步函数调用
image::image185.png[]

函数 A 在处理一批事件时调用函数 B，函数 A 一旦处理完成，就会更新其消费者偏移量并终止运行。同时，函数 B 将继续它的处理并输出数据到输出事件流。

异步直接调用的一个主要缺点是难以确保仅在事件得到成功处理时更新消费者偏移量。在这个例子中，因为函数 B 不会返回结果给函数 A，所以函数 B 发生错误时不会阻止工作流提交错误的消费者组偏移量。但是，对一些工作流来说是可以接受事件丢失的，在此类场景中这个问题可以被忽略。

另一个潜在的主要问题是，由于多次调用函数 B，事件的处理可能是乱序的。考虑以下函数 A 的代码。

----
public int functionA(Event[] events, Context context) {
    for(Event event: events) {
        //执行函数A的处理工作

        //对于每个事件异步调用函数B
        //不等待函数B的返回值
        asyncfunctionB(event);
    }
    context.success();
    return 0;
}
----

在函数 A 的工作逻辑中内联调用函数 B。根据不同的 FaaS 框架，有可能会创建多个函数 B 实例，它们是独立运行的。这将创建一种竞争条件，其中函数 B 的某些实例会早于其他实例完成执行，因此可能会导致乱序的事件处理。

类似的，像下面这样编写代码也无法解决顺序问题。因为函数 A 会在函数 B 执行之前批处理所有事件，所以仍然会出现乱序处理的情况。

----
public int functionA(Event[] events, Context context) {
    for(Event event: events) {
        //执行函数A的处理工作
    }
    //用批量事件参数异步调用函数B
    asyncFunctionB(events);

    context.success()
    return 0;
}
----

顺序处理要求对于每个事件严格地执行完函数 A 之后再执行函数 B，接着再处理下一个事件。必须完全处理完一个事件之后才能启动下一个事件，否则很可能导致不确定性行为。当函数 A 和函数 B在操作相同的外部数据存储时更是如此，因为函数 B 可能会依赖于函数 A 所写的数据。

在许多情况下，异步调用不足以满足界限上下文的需求，因此要考虑是否用编制型的直接调用模式会更合适。

pass:[2. 编制模式与同步的函数调用]

同步的函数调用允许调用其他函数并等待结果，然后再处理剩下的业务逻辑。这可以用第 8 章介绍的编制模式来实现。

事件流触发的处理。在下面这个例子中，当新事件到达分区的事件流时，会触发编制器函数执行。该函数会启动并开始处理一批输入事件，然后依次向每个函数分发事件。图 9-5 展示了一个在单一的界限上下文中基于函数的编制模式的例子。

.图 9-5：在一个界限上下文中的编制型同步函数调用
image::image186.png[]

以下是编制器的示例代码。

----
public int orchestrationFunction(Event[] events, Context context) {
    for(Event event: events) {
        //同步的函数调用
        Result resultFromA = invokeFunctionA(event);
        Result resultFromB = invokeFunctionB(event, resultFromA);
        Output output = composeOutputEvent(resultFromA, resultFromB); //写到输出事件流
        producer.produce("Output Stream", output);
    }
    //这会通知FaaS框架更新消费者偏移量
    context.success();
    return 0;
}
----

编制器函数按顺序调用函数 A 和函数 B，并等待每个函数的结果。如果需要，可以将函数 A 的输出发送给函数 B。工作流在完全处理完当前事件之后才会开启下一个事件的处理，这确保了按照偏移量顺序来进行事件处理。一旦消费者函数处理完一批事件，它就可以发出一条成功消息并相应地更新偏移量。

队列驱动的事件处理。如果使用具有单独提交功能的队列，则每个事件都可以触发一个单独的编制器函数。编制器需要在完成处理工作后向队列提交处理确认。如果编制器未能完成处理工作，那么该任务将被新创建的下一个编制器实例接收。

[#_9_9_终止和关闭]
== 9.9 终止和关闭

一旦函数完成其工作，或者存活期限到期（通常配置为 5~10 分钟），就会终止执行。函数实例被挂起并进入休眠状态，在该状态下实例是可以立即恢复的。由于资源或时间限制，挂起的函数最终也可能被彻底清除。

你需要确定在函数终止之前如何处理所有建立的连接和分配的资源。如果是作为一个消费者客户端，那么函数实例会被分配特定的事件流分区。终止函数实例而不撤销这些分配可能会导致处理延迟，因为只有在发生超时之后才会重新分配消费者组中的分区处理权。在消费者组执行再平衡或终止的函数实例重新上线并恢复处理之前，来自这些分区的事件不会得到处理。

如果一个函数一直在线且正在处理事件，那么关闭连接和再平衡消费者组是没有必要的。该函数可能只会在其存活期限结束时暂时挂起，短暂进入休眠状态，并立即恢复到运行状态。相反，对于仅间歇运行的消费者函数，最好关闭所有连接并放弃事件流分区的分配。下一个函数实例必须重新创建连接，无论其是冷启动还是热启动。当不确定要如何处理时，清除连接通常是一个好的做法：它减轻了外部数据存储和事件代理的负载，并减少了挂起的函数占用分区处理权的机会。

[#_9_10_调整函数]
== 9.10 调整函数

每个函数都有基于其工作量的具体需求。优化函数在执行期间使用的资源可以确保在保持低成本的同时保持高性能。在建立资源和调整函数的参数时，有一些事情需要考虑。

[#_9_10_1_分配足够的资源]
=== 9.10.1 分配足够的资源

每个函数可以被分配一定量的 CPU 和内存资源。重要的是要根据函数需求来调整这些参数：过度分配会使成本变高，过少分配则可能导致函数崩溃或耗时太久。

最大执行时间是另一个要考虑的因素，因为它限制了函数可能运行的时长。这个参数与批处理的大小密切相关，因为函数处理事件的时间通常与要处理的事件数呈线性关系。将最大执行时间设置为高于处理特定批量大小事件的最大预期时间，以避免不必要的函数超时错误。

最后，还必须考虑 FaaS 解决方案的界限上下文中对状态存储的所有外部 I/O。函数的工作负载随输入事件流的变化而变化，有些工作负载需要对外部状态进行持续的 I/O 操作，而其他工作负载只需要零星的I/O。未能提供足够的 I/O 资源会导致吞吐量和性能降低。

[#_9_10_2_批量事件处理的参数]
=== 9.10.2 批量事件处理的参数

如果函数无法在其执行时间期限内处理分配给它的批量事件，那么函数的执行就被认为是失败的并且必须重新进行批处理。但是，除非调整分配给函数的执行时间或输入事件的批量大小，否则处理很可能再次失败。因此，必须至少调整以下两项配置中的其中一项：

* 增加函数的最大执行时间；
* 减小函数要处理的事件的最大批处理大小。

image:image3.png[image,width=40,height=46]
自己建立到事件代理的连接并管理事件消费的函数，可以做到在执行期间定期提交偏移量，以确保批处理的部分完结。当只是将一批待消费的事件传递给函数进行业务处理时则没办法做到这点，因为它无法在处理过程中更新消费者偏移量。

此外，一些事件监听器触发系统（比如亚马逊和微软提供的系统），允许你在出现失败时自动将批处理大小减半，并重新执行失败的函数。随后再发生错误会导致批处理的量再次减半，再次执行函数，直到它能够按时完成处理为止。

[#_9_11_faas的伸缩方案]
== 9.11 FaaS的伸缩方案

FaaS 解决方案为工作的并行化提供了卓越的能力，特别是对于数据处理顺序不重要的队列和事件流。对于分区的事件流，如果事件的顺序确实很重要，那么并行化的最大程度会受限于事件流的分区数，就如所有微服务实现那样。

伸缩策略通常由 FaaS 框架提供，请检查你的框架文档确认其提供了哪些选项。常见的选项基于消费者滞后度、一天中的特定时间段、处理吞吐量和性能指标等维度进行伸缩。

对于自己负责实例化和管理事件代理连接的函数，请注意当消费者进入或离开消费者组时分区分配再平衡的影响。如果消费者频繁地加入或离开消费者组，那么消费者组最终可能会处于一种近乎持续的再平衡状态，从而无法取得处理进展。在极端情况下，其可能会陷入再平衡的虚拟死锁中，函数在其生命周期中反复分配和删除分区。当使用的函数存活期限较短且批处理的量较小时，可能会出现此问题，并且对延迟过于敏感的伸缩策略会使问题变得更糟。建立基于 step 的伸缩策略或使用滞后环可以保障有足够的伸缩响应，同时不会使消费者组进入过度再平衡的状态。

静态分区分配消除了动态分配的消费者组的再平衡开销，也可用于协同分区事件流。函数将预先知道它们会从哪些分区进行消费。不需要再平衡，只要触发该函数，就可以简单地消费事件。采用这种方法需要更仔细地考虑函数所执行的工作，因为你需要确保每个分区都能得到消费。

image:image5.png[image,width=47,height=44]
要小心抖动的触发器和伸缩策略。频繁的分区分配再平衡对事件代理来说是成本高昂的。尽量保证在几分钟的间隔内只能向上或向下进行一次函数的伸缩。

[#_9_12_小结]
== 9.12 小结

FaaS 属于云计算的其中一个领域并且正处在高速发展阶段。许多 FaaS 框架提供了多种函数开发、管理、部署、触发、测试和伸缩工具，让你可以使用函数构建自己的微服务。可以通过事件流中的新事件、消费者组滞后状态、挂钟时间和自定义逻辑触发函数。

基于函数的解决方案在处理不需要事件调度的无状态和简单有状态业务问题时特别有用。编制模式可以按严格的顺序调用多个函数，同时也遵从来自事件流的事件顺序。由于 FaaS 框架正在快速地发展，因此保持跟踪你所感兴趣的 FaaS 平台的最新特性是非常重要的。
