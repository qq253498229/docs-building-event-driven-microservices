* xref:copyright.adoc[版权声明]
* xref:o_reilly_media_inc_introduction.adoc[O'Reilly Media, Inc. 介绍]
** xref:industry_evaluation.adoc[业界评论]
* xref:introduction.adoc[前言]
** xref:typesetting_convention.adoc[排版约定]
** xref:o_reilly_online_learning_platform.adoc[O'Reilly在线学习平台（O'Reilly Online Learning）]
** xref:contact_us.adoc[联系我们]
** xref:acknowledgments.adoc[致谢]
** xref:more_information.adoc[更多信息]
* xref:1.adoc[第 1 章 为什么用事件驱动型微服务]
** xref:1.adoc#_1_1_什么是事件驱动型微服务[1.1 什么是事件驱动型微服务]
** xref:1.adoc#_1_2_领域驱动设计和界限上下文[1.2 领域驱动设计和界限上下文]
*** xref:1.adoc#_1_2_1_运用领域模型和界限上下文[1.2.1 运用领域模型和界限上下文]
*** xref:1.adoc#_1_2_2_保持界限上下文与业务需求一致[1.2.2 保持界限上下文与业务需求一致]
** xref:1.adoc#_1_3_沟通结构[1.3 沟通结构]
*** xref:1.adoc#_1_3_1_业务沟通结构[1.3.1 业务沟通结构]
*** xref:1.adoc#_1_3_2_实现沟通结构[1.3.2 实现沟通结构]
*** xref:1.adoc#_1_3_3_数据沟通结构[1.3.3 数据沟通结构]
*** xref:1.adoc#_1_3_4_康威定律和沟通结构[1.3.4 康威定律和沟通结构]
** xref:1.adoc#_1_4_传统计算中的沟通结构[1.4 传统计算中的沟通结构]
*** xref:1.adoc#_1_4_1_选项1创建一个新服务[1.4.1 选项1：创建一个新服务]
*** xref:1.adoc#_1_4_2_选项2将它加入现有服务中[1.4.2 选项2：将它加入现有服务中]
*** xref:1.adoc#_1_4_3_两种选项的利弊[1.4.3 两种选项的利弊]
*** xref:1.adoc#_1_4_4_团队场景续[1.4.4 团队场景（续）]
*** xref:1.adoc#_1_4_5_冲突的压力[1.4.5 冲突的压力]
** xref:1.adoc#_1_5_事件驱动的沟通结构[1.5 事件驱动的沟通结构]
*** xref:1.adoc#_1_5_1_事件是通信的基础[1.5.1 事件是通信的基础]
*** xref:1.adoc#_1_5_2_事件流提供了单一事实来源[1.5.2 事件流提供了单一事实来源]
*** xref:1.adoc#_1_5_3_消费者执行自己的建模和查询[1.5.3 消费者执行自己的建模和查询]
*** xref:1.adoc#_1_5_4_整个组织的数据沟通得到改善[1.5.4 整个组织的数据沟通得到改善]
*** xref:1.adoc#_1_5_5_高可访问的数据利于业务变更[1.5.5 高可访问的数据利于业务变更]
** xref:1.adoc#_1_6_异步的事件驱动型微服务[1.6 异步的事件驱动型微服务]
*** xref:1.adoc#_使用事件驱动型微服务的示例团队[使用事件驱动型微服务的示例团队]
** xref:1.adoc#_1_7_同步式微服务[1.7 同步式微服务]
*** xref:1.adoc#_1_7_1_同步式微服务的缺点[1.7.1 同步式微服务的缺点]
*** xref:1.adoc#_1_7_2_同步式微服务的优点[1.7.2 同步式微服务的优点]
** xref:1.adoc#_1_8_小结[1.8 小结]
* xref:2.adoc[第 2 章 事件驱动型微服务基础]
** xref:2.adoc#_2_1_构建拓扑[2.1 构建拓扑]
*** xref:2.adoc#_2_1_1_微服务拓扑[2.1.1 微服务拓扑]
*** xref:2.adoc#_2_1_2_业务拓扑[2.1.2 业务拓扑]
** xref:2.adoc#_2_2_事件内容[2.2 事件内容]
** xref:2.adoc#_2_3_事件的结构[2.3 事件的结构]
*** xref:2.adoc#_2_3_1_无键事件[2.3.1 无键事件]
*** xref:2.adoc#_2_3_2_实体事件[2.3.2 实体事件]
*** xref:2.adoc#_2_3_3_键控事件[2.3.3 键控事件]
** xref:2.adoc#_2_4_物化来自实体事件的状态[2.4 物化来自实体事件的状态]
** xref:2.adoc#_2_5_事件数据的定义和schema[2.5 事件数据的定义和schema]
** xref:2.adoc#_2_6_微服务单一写原则[2.6 微服务单一写原则]
** xref:2.adoc#_2_7_用事件代理赋能微服务[2.7 用事件代理赋能微服务]
*** xref:2.adoc#_2_7_1_事件存储和服务[2.7.1 事件存储和服务]
*** xref:2.adoc#_2_7_2_需要考虑的其他因素[2.7.2 需要考虑的其他因素]
** xref:2.adoc#_2_8_事件代理与消息代理[2.8 事件代理与消息代理]
*** xref:2.adoc#_2_8_1_从不可变日志中消费[2.8.1 从不可变日志中消费]
*** xref:2.adoc#_2_8_2_提供单一事实来源[2.8.2 提供单一事实来源]
** xref:2.adoc#_2_9_大规模管理微服务[2.9 大规模管理微服务]
*** xref:2.adoc#_2_9_1_将微服务放到容器内[2.9.1 将微服务放到容器内]
*** xref:2.adoc#_2_9_2_将微服务放到虚拟机内[2.9.2 将微服务放到虚拟机内]
*** xref:2.adoc#_2_9_3_管理容器和虚拟机[2.9.3 管理容器和虚拟机]
** xref:2.adoc#_2_10_缴纳微服务税[2.10 缴纳微服务税]
** xref:2.adoc#_2_11_小结[2.11 小结]
* xref:3.adoc[第 3 章 通信和数据契约]
** xref:3.adoc#_3_1_事件驱动数据契约[3.1 事件驱动数据契约]
*** xref:3.adoc#_3_1_1_使用显式schema作为契约[3.1.1 使用显式schema作为契约]
*** xref:3.adoc#_3_1_2_schema定义的注释[3.1.2 schema定义的注释]
*** xref:3.adoc#_3_1_3_全能的schema演化[3.1.3 全能的schema演化]
*** xref:3.adoc#_3_1_4_有代码生成器支持[3.1.4 有代码生成器支持]
*** xref:3.adoc#_3_1_5_破坏性的schema变更[3.1.5 破坏性的schema变更]
** xref:3.adoc#_3_2_选择事件格式[3.2 选择事件格式]
** xref:3.adoc#_3_3_设计事件[3.3 设计事件]
*** xref:3.adoc#_3_3_1_只讲述事实[3.3.1 只讲述事实]
*** xref:3.adoc#_3_3_2_每个流都使用单一事件定义[3.3.2 每个流都使用单一事件定义]
*** xref:3.adoc#_3_3_3_使用最窄的数据类型[3.3.3 使用最窄的数据类型]
*** xref:3.adoc#_3_3_4_保持事件的单一用途[3.3.4 保持事件的单一用途]
*** xref:3.adoc#_3_3_5_最小化事件[3.3.5 最小化事件]
*** xref:3.adoc#_3_3_6_让潜在的消费者参与事件设计[3.3.6 让潜在的消费者参与事件设计]
*** xref:3.adoc#_3_3_7_避免将事件作为信号量或信号[3.3.7 避免将事件作为信号量或信号]
** xref:3.adoc#_3_4_小结[3.4 小结]
* xref:4.adoc[第 4 章 将事件驱动架构与现有系统集成]
** xref:4.adoc#_4_1_什么是数据解放[4.1 什么是数据解放]
*** xref:4.adoc#_4_1_1_数据解放的折中方案[4.1.1 数据解放的折中方案]
*** xref:4.adoc#_4_1_2_将被解放的数据转化成事件[4.1.2 将被解放的数据转化成事件]
** xref:4.adoc#_4_2_数据解放模式[4.2 数据解放模式]
** xref:4.adoc#_4_3_数据解放框架[4.3 数据解放框架]
** xref:4.adoc#_4_4_通过查询实施数据解放[4.4 通过查询实施数据解放]
*** xref:4.adoc#_4_4_1_批量加载[4.4.1 批量加载]
*** xref:4.adoc#_4_4_2_增量时间戳加载[4.4.2 增量时间戳加载]
*** xref:4.adoc#_4_4_3_自增id加载[4.4.3 自增ID加载]
*** xref:4.adoc#_4_4_4_自定义查询[4.4.4 自定义查询]
*** xref:4.adoc#_4_4_5_增量更新[4.4.5 增量更新]
*** xref:4.adoc#_4_4_6_基于查询更新的优点[4.4.6 基于查询更新的优点]
*** xref:4.adoc#_4_4_7_基于查询更新的缺点[4.4.7 基于查询更新的缺点]
** xref:4.adoc#_4_5_使用变更数据捕获日志解放数据[4.5 使用变更数据捕获日志解放数据]
*** xref:4.adoc#_4_5_1_使用数据存储日志的优点[4.5.1 使用数据存储日志的优点]
*** xref:4.adoc#_4_5_2_使用数据库日志的缺点[4.5.2 使用数据库日志的缺点]
** xref:4.adoc#_4_6_使用发件箱表解放数据[4.6 使用发件箱表解放数据]
*** xref:4.adoc#_4_6_1_性能考虑[4.6.1 性能考虑]
*** xref:4.adoc#_4_6_2_隔离内部数据模型[4.6.2 隔离内部数据模型]
*** xref:4.adoc#_4_6_3_确保schema兼容性[4.6.3 确保schema兼容性]
*** xref:4.adoc#_4_6_4_使用触发器捕获变更数据[4.6.4 使用触发器捕获变更数据]
** xref:4.adoc#_4_7_对处于捕获的数据集做数据定义变更[4.7 对处于捕获的数据集做数据定义变更]
*** xref:4.adoc#_4_7_1_为查询和cdc日志模式处理事后数据定义变更[4.7.1 为查询和CDC日志模式处理事后数据定义变更]
*** xref:4.adoc#_4_7_2_为变更数据表捕获模式处理数据定义变更[4.7.2 为变更数据表捕获模式处理数据定义变更]
** xref:4.adoc#_4_8_将事件数据落地到数据存储[4.8 将事件数据落地到数据存储]
** xref:4.adoc#_4_9_数据落地和获取对业务的影响[4.9 数据落地和获取对业务的影响]
** xref:4.adoc#_4_10_小结[4.10 小结]
* xref:5.adoc[第 5 章 事件驱动处理基础]
** xref:5.adoc#_5_1_构建无状态拓扑[5.1 构建无状态拓扑]
*** xref:5.adoc#_5_1_1_转换[5.1.1 转换]
*** xref:5.adoc#_5_1_2_分流与合流[5.1.2 分流与合流]
** xref:5.adoc#_5_2_对事件流再分区[5.2 对事件流再分区]
*** xref:5.adoc#_示例对一个事件流再分区[示例：对一个事件流再分区]
** xref:5.adoc#_5_3_对事件流协同分区[5.3 对事件流协同分区]
*** xref:5.adoc#_示例对一个事件流进行协同分区[示例：对一个事件流进行协同分区]
** xref:5.adoc#_5_4_给消费者实例分配分区[5.4 给消费者实例分配分区]
*** xref:5.adoc#_5_4_1_使用分区分配器分配分区[5.4.1 使用分区分配器分配分区]
*** xref:5.adoc#_5_4_2_分配协同分区[5.4.2 分配协同分区]
*** xref:5.adoc#_5_4_3_分区分配策略[5.4.3 分区分配策略]
** xref:5.adoc#_5_5_从无状态处理实例故障中恢复[5.5 从无状态处理实例故障中恢复]
** xref:5.adoc#_5_6_小结[5.6 小结]
* xref:6.adoc[第 6 章 具有确定性的流处理]
** xref:6.adoc#_6_1_事件驱动工作流的确定性[6.1 事件驱动工作流的确定性]
** xref:6.adoc#_6_2_时间戳[6.2 时间戳]
*** xref:6.adoc#_6_2_1_同步分布式时间戳[6.2.1 同步分布式时间戳]
*** xref:6.adoc#_6_2_2_处理带时间戳的事件[6.2.2 处理带时间戳的事件]
** xref:6.adoc#_6_3_事件调度和确定性处理[6.3 事件调度和确定性处理]
*** xref:6.adoc#_6_3_1_自定义事件调度器[6.3.1 自定义事件调度器]
*** xref:6.adoc#_6_3_2_基于事件时间处理时间和摄取时间进行处理[6.3.2 基于事件时间、处理时间和摄取时间进行处理]
*** xref:6.adoc#_6_3_3_消费者提取时间戳[6.3.3 消费者提取时间戳]
*** xref:6.adoc#_6_3_4_对外部系统的请求响应调用[6.3.4 对外部系统的“请求–响应”调用]
** xref:6.adoc#_6_4_水位[6.4 水位]
*** xref:6.adoc#_并行处理中的水位[并行处理中的水位]
** xref:6.adoc#_6_5_流时间[6.5 流时间]
*** xref:6.adoc#_并行处理中的流时间[并行处理中的流时间]
** xref:6.adoc#_6_6_乱序事件和迟到事件[6.6 乱序事件和迟到事件]
*** xref:6.adoc#_6_6_1_使用水位和流时间的迟到事件[6.6.1 使用水位和流时间的迟到事件]
*** xref:6.adoc#_6_6_2_乱序事件的原因和影响[6.6.2 乱序事件的原因和影响]
*** xref:6.adoc#_6_6_3_时间敏感的函数和窗口化[6.6.3 时间敏感的函数和窗口化]
** xref:6.adoc#_6_7_处理迟到事件[6.7 处理迟到事件]
** xref:6.adoc#_6_8_再处理与近实时处理[6.8 再处理与近实时处理]
** xref:6.adoc#_6_9_间歇性故障和迟到事件[6.9 间歇性故障和迟到事件]
** xref:6.adoc#_6_10_生产者事件代理的连接性问题[6.10 生产者/事件代理的连接性问题]
** xref:6.adoc#_6_11_小结与延展阅读[6.11 小结与延展阅读]
* xref:7.adoc[第 7 章 有状态的流]
** xref:7.adoc#_7_1_状态存储与从事件流中物化状态[7.1 状态存储与从事件流中物化状态]
** xref:7.adoc#_7_2_记录状态到变更日志事件流[7.2 记录状态到变更日志事件流]
** xref:7.adoc#_7_3_将状态物化至内部状态存储[7.3 将状态物化至内部状态存储]
*** xref:7.adoc#_7_3_1_物化全局状态[7.3.1 物化全局状态]
*** xref:7.adoc#_7_3_2_使用内部状态的优点[7.3.2 使用内部状态的优点]
*** xref:7.adoc#_7_3_3_使用内部状态的缺点[7.3.3 使用内部状态的缺点]
*** xref:7.adoc#_7_3_4_内部状态的伸缩和恢复[7.3.4 内部状态的伸缩和恢复]
** xref:7.adoc#_7_4_将状态物化至外部状态存储[7.4 将状态物化至外部状态存储]
*** xref:7.adoc#_7_4_1_外部状态的优点[7.4.1 外部状态的优点]
*** xref:7.adoc#_7_4_2_外部状态的缺点[7.4.2 外部状态的缺点]
*** xref:7.adoc#_7_4_3_外部状态存储的伸缩和恢复[7.4.3 外部状态存储的伸缩和恢复]
** xref:7.adoc#_7_5_重建与迁移状态存储[7.5 重建与迁移状态存储]
*** xref:7.adoc#_7_5_1_重建[7.5.1 重建]
*** xref:7.adoc#_7_5_2_迁移[7.5.2 迁移]
** xref:7.adoc#_7_6_事务与有效一次处理[7.6 事务与有效一次处理]
*** xref:7.adoc#_7_6_1_示例库存计算服务[7.6.1 示例：库存计算服务]
*** xref:7.adoc#_7_6_2_使用客户端代理事务的有效一次处理[7.6.2 使用“客户端–代理”事务的有效一次处理]
*** xref:7.adoc#_7_6_3_没有客户端代理事务的有效一次处理[7.6.3 没有“客户端–代理”事务的有效一次处理]
** xref:7.adoc#_7_7_小结[7.7 小结]
* xref:8.adoc[第 8 章 用微服务构建工作流]
** xref:8.adoc#_8_1_编排模式[8.1 编排模式]
*** xref:8.adoc#_8_1_1_一个简单的事件驱动编排示例[8.1.1 一个简单的事件驱动编排示例]
*** xref:8.adoc#_8_1_2_创建和修改编排的工作流[8.1.2 创建和修改编排的工作流]
*** xref:8.adoc#_8_1_3_监控编排的工作流[8.1.3 监控编排的工作流]
** xref:8.adoc#_8_2_编制模式[8.2 编制模式]
*** xref:8.adoc#_8_2_1_一个简单的事件驱动编制模式例子[8.2.1 一个简单的事件驱动编制模式例子]
*** xref:8.adoc#_8_2_2_一个简单的直接调用的编制模式例子[8.2.2 一个简单的直接调用的编制模式例子]
*** xref:8.adoc#_8_2_3_对比事件驱动编制模式和直接调用的编制模式[8.2.3 对比事件驱动编制模式和直接调用的编制模式]
*** xref:8.adoc#_8_2_4_创建和修改编制工作流[8.2.4 创建和修改编制工作流]
*** xref:8.adoc#_8_2_5_监控编制工作流[8.2.5 监控编制工作流]
** xref:8.adoc#_8_3_分布式事务[8.3 分布式事务]
*** xref:8.adoc#_8_3_1_编排型事务saga模式[8.3.1 编排型事务：saga模式]
*** xref:8.adoc#_8_3_2_编制型事务[8.3.2 编制型事务]
** xref:8.adoc#_8_4_补偿工作流[8.4 补偿工作流]
** xref:8.adoc#_8_5_小结[8.5 小结]
* xref:9.adoc[第 9 章 使用“函数即服务”的微服务]
** xref:9.adoc#_9_1_设计基于函数的微服务解决方案[9.1 设计基于函数的微服务解决方案]
*** xref:9.adoc#_9_1_1_确保界限上下文的严格的成员关系[9.1.1 确保界限上下文的严格的成员关系]
*** xref:9.adoc#_9_1_2_只在完成处理之后提交偏移量[9.1.2 只在完成处理之后提交偏移量]
*** xref:9.adoc#_9_1_3_少即是多[9.1.3 少即是多]
** xref:9.adoc#_9_2_选择faas供应商[9.2 选择FaaS供应商]
** xref:9.adoc#_9_3_在函数之外构建微服务[9.3 在函数之外构建微服务]
** xref:9.adoc#_9_4_冷启动和热启动[9.4 冷启动和热启动]
** xref:9.adoc#_9_5_用触发器启动函数[9.5 用触发器启动函数]
*** xref:9.adoc#_9_5_1_基于新事件触发事件流监听器[9.5.1 基于新事件触发：事件流监听器]
*** xref:9.adoc#_9_5_2_基于消费者组的滞后度触发[9.5.2 基于消费者组的滞后度触发]
*** xref:9.adoc#_9_5_3_按调度表触发[9.5.3 按调度表触发]
*** xref:9.adoc#_9_5_4_使用网络钩子触发[9.5.4 使用网络钩子触发]
*** xref:9.adoc#_9_5_5_触发资源事件[9.5.5 触发资源事件]
** xref:9.adoc#_9_6_用函数执行业务工作[9.6 用函数执行业务工作]
** xref:9.adoc#_9_7_维持状态[9.7 维持状态]
** xref:9.adoc#_9_8_调用其他函数的函数[9.8 调用其他函数的函数]
*** xref:9.adoc#_9_8_1_事件驱动通信模式[9.8.1 事件驱动通信模式]
*** xref:9.adoc#_9_8_2_直接调用模式[9.8.2 直接调用模式]
** xref:9.adoc#_9_9_终止和关闭[9.9 终止和关闭]
** xref:9.adoc#_9_10_调整函数[9.10 调整函数]
*** xref:9.adoc#_9_10_1_分配足够的资源[9.10.1 分配足够的资源]
*** xref:9.adoc#_9_10_2_批量事件处理的参数[9.10.2 批量事件处理的参数]
** xref:9.adoc#_9_11_faas的伸缩方案[9.11 FaaS的伸缩方案]
** xref:9.adoc#_9_12_小结[9.12 小结]
* xref:10.adoc[第 10 章 基础的生产者和消费者微服务]
** xref:10.adoc#_10_1_bpc的适用场合[10.1 BPC的适用场合]
*** xref:10.adoc#_10_1_1_集成现有遗留系统[10.1.1 集成现有遗留系统]
*** xref:10.adoc#_10_1_2_不依赖于事件顺序的有状态的业务逻辑[10.1.2 不依赖于事件顺序的有状态的业务逻辑]
*** xref:10.adoc#_10_1_3_当数据层完成大部分工作时[10.1.3 当数据层完成大部分工作时]
*** xref:10.adoc#_10_1_4_处理层和数据层独立伸缩[10.1.4 处理层和数据层独立伸缩]
** xref:10.adoc#_10_2_具有外部流处理的混合bpc应用程序[10.2 具有外部流处理的混合BPC应用程序]
*** xref:10.adoc#_示例使用外部流处理框架来联结事件流[示例：使用外部流处理框架来联结事件流]
** xref:10.adoc#_10_3_小结[10.3 小结]
* xref:11.adoc[第 11 章 使用重量级框架的微服务]
** xref:11.adoc#_11_1_重量级框架的简单历史[11.1 重量级框架的简单历史]
** xref:11.adoc#_11_2_重量级框架的内部运作[11.2 重量级框架的内部运作]
** xref:11.adoc#_11_3_优点和局限性[11.3 优点和局限性]
** xref:11.adoc#_11_4_集群搭建方案和执行模式[11.4 集群搭建方案和执行模式]
*** xref:11.adoc#_11_4_1_使用托管服务[11.4.1 使用托管服务]
*** xref:11.adoc#_11_4_2_构建自己的完整集群[11.4.2 构建自己的完整集群]
*** xref:11.adoc#_11_4_3_使用cms集成来创建集群[11.4.3 使用CMS集成来创建集群]
** xref:11.adoc#_11_5_应用程序提交模式[11.5 应用程序提交模式]
*** xref:11.adoc#_11_5_1_驱动器模式[11.5.1 驱动器模式]
*** xref:11.adoc#_11_5_2_集群模式[11.5.2 集群]
** xref:11.adoc#_11_6_处理状态和使用检查点[11.6 处理状态和使用检查点]
** xref:11.adoc#_11_7_伸缩应用程序和处理事件流分区[11.7 伸缩应用程序和处理事件流分区]
*** xref:11.adoc#_11_7_1_伸缩运行中的应用程序[11.7.1 伸缩运行中的应用程序]
*** xref:11.adoc#_11_7_2_通过重启伸缩应用程序[11.7.2 通过重启伸缩应用程序]
*** xref:11.adoc#_11_7_3_自动伸缩应用程序[11.7.3 自动伸缩应用程序]
** xref:11.adoc#_11_8_从故障中恢复[11.8 从故障中恢复]
** xref:11.adoc#_11_9_考虑多租户问题[11.9 考虑多租户问题]
** xref:11.adoc#_11_10_语言和语法[11.10 语言和语法]
** xref:11.adoc#_11_11_选择一个框架[11.11 选择一个框架]
** xref:11.adoc#_11_12_示例点击和观看的会话窗口[11.12 示例：点击和观看的会话窗口]
** xref:11.adoc#_11_13_小结[11.13 小结]
* xref:12.adoc[第 12 章 使用轻量级框架的微服务]
** xref:12.adoc#_12_1_优点和局限性[12.1 优点和局限性]
** xref:12.adoc#_12_2_轻量级处理[12.2 轻量级处理]
** xref:12.adoc#_12_3_处理状态和使用变更日志[12.3 处理状态和使用变更日志]
** xref:12.adoc#_12_4_伸缩和故障恢复[12.4 伸缩和故障恢复]
*** xref:12.adoc#_12_4_1_事件洗牌[12.4.1 事件洗牌]
*** xref:12.adoc#_12_4_2_状态分配[12.4.2 状态分配]
*** xref:12.adoc#_12_4_3_状态复制和热副本[12.4.3 状态复制和热副本]
** xref:12.adoc#_12_5_选择一个轻量级框架[12.5 选择一个轻量级框架]
*** xref:12.adoc#_12_5_1_apache_kafka_streams[12.5.1 Apache Kafka Streams]
*** xref:12.adoc#_12_5_2_apache_samza嵌入模式[12.5.2 Apache Samza：嵌入模式]
** xref:12.adoc#_12_6_语言和语法[12.6 语言和语法]
** xref:12.adoc#_12_7_流表表联结增强模式[12.7 流–表–表联结：增强模式]
** xref:12.adoc#_12_8_小结[12.8 小结]
* xref:13.adoc[第 13 章 集成事件驱动型和“请求–响应”型微服务]
** xref:13.adoc#_13_1_处理外部事件[13.1 处理外部事件]
*** xref:13.adoc#_13_1_1_自动生成的事件[13.1.1 自动生成的事件]
*** xref:13.adoc#_13_1_2_由响应生成的事件[13.1.2 由响应生成的事件]
** xref:13.adoc#_13_2_处理自动生成的分析事件[13.2 处理自动生成的分析事件]
** xref:13.adoc#_13_3_集成第三方请求响应api[13.3 集成第三方“请求–响应”API]
** xref:13.adoc#_13_4_处理并提供有状态的数据[13.4 处理并提供有状态的数据]
*** xref:13.adoc#_13_4_1_实时请求内部状态存储[13.4.1 实时请求内部状态存储]
*** xref:13.adoc#_13_4_2_实时请求外部状态存储[13.4.2 实时请求外部状态存储]
** xref:13.adoc#_13_5_在事件驱动的工作流中处理请求[13.5 在事件驱动的工作流中处理请求]
*** xref:13.adoc#_处理用户界面事件[处理用户界面事件]
** xref:13.adoc#_13_6_请求响应应用程序中的微前端[13.6 “请求–响应”应用程序中的微前端]
** xref:13.adoc#_13_7_微前端的优点[13.7 微前端的优点]
*** xref:13.adoc#_13_7_1_基于组合的微服务[13.7.1 基于组合的微服务]
*** xref:13.adoc#_13_7_2_容易与业务需求对齐[13.7.2 容易与业务需求对齐]
** xref:13.adoc#_13_8_微前端的缺点[13.8 微前端的缺点]
*** xref:13.adoc#_13_8_1_可能不一致的ui元素和样式[13.8.1 可能不一致的UI元素和样式]
*** xref:13.adoc#_13_8_2_不同的微前端性能[13.8.2 不同的微前端性能]
*** xref:13.adoc#_13_8_3_示例体验搜索与评论应用程序[13.8.3 示例：体验搜索与评论应用]
** xref:13.adoc#_13_9_小结[13.9 小结]
* xref:14.adoc[第 14 章 支持性工具]
** xref:14.adoc#_14_1_微服务团队分配系统[14.1 微服务–团队分配系统]
** xref:14.adoc#_14_2_事件流的创建和修改[14.2 事件流的创建和修改]
** xref:14.adoc#_14_3_事件流元数据标记[14.3 事件流元数据标记]
** xref:14.adoc#_14_4_限额[14.4 限额]
** xref:14.adoc#_14_5_schema注册表[14.5 schema注册表]
** xref:14.adoc#_14_6_schema创建和修改通知[14.6 schema创建和修改通知]
** xref:14.adoc#_14_7_偏移量管理[14.7 偏移量管理]
** xref:14.adoc#_14_8_事件流的权限和访问控制列表[14.8 事件流的权限和访问控制列表]
** xref:14.adoc#_14_9_状态管理和应用程序重置[14.9 状态管理和应用程序重置]
** xref:14.adoc#_14_10_消费者偏移量滞后度监控[14.10 消费者偏移量滞后度]
** xref:14.adoc#_14_11_流水线型的微服务创建流程[14.11 流水线型的微服务创建流程]
** xref:14.adoc#_14_12_容器管理控制[14.12 容器管理控制]
** xref:14.adoc#_14_13_集群创建和管理[14.13 集群创建和管理]
*** xref:14.adoc#_14_13_1_事件代理的程序化创建[14.13.1 事件代理的程序化创建]
*** xref:14.adoc#_14_13_2_计算资源的程序化创建[14.13.2 计算资源的程序化创建]
*** xref:14.adoc#_14_13_3_跨集群事件数据复制[14.13.3 跨集群事件数据复制]
*** xref:14.adoc#_14_13_4_工具的程序化创建[14.13.4 工具的程序化创建]
** xref:14.adoc#_14_14_依赖跟踪和拓扑可视化[14.14 依赖跟踪和拓扑可视化]
*** xref:14.adoc#_拓扑示例[拓扑示例]
** xref:14.adoc#_14_15_小结[14.15 小结]
* xref:15.adoc[第 15 章 测试事件驱动型微服务]
** xref:15.adoc#_15_1_通用测试原则[15.1 通用测试原则]
** xref:15.adoc#_15_2_单元测试拓扑函数[15.2 单元测试拓扑函数]
*** xref:15.adoc#_15_2_1_无状态的函数[15.2.1 无状态的函数]
*** xref:15.adoc#_15_2_2_有状态的函数[15.2.2 有状态的函数]
** xref:15.adoc#_15_3_测试拓扑[15.3 测试拓扑]
** xref:15.adoc#_15_4_测试schema演化和兼容性[15.4 测试schema演化和兼容性]
** xref:15.adoc#_15_5_事件驱动型微服务的集成测试[15.5 事件驱动型微服务的集成测试]
** xref:15.adoc#_15_6_本地集成测试[15.6 本地集成测试]
*** xref:15.adoc#_15_6_1_在测试代码的运行时内创建临时环境[15.6.1 在测试代码的运行时内创建临时环境]
*** xref:15.adoc#_15_6_2_在测试代码外部创建临时环境[15.6.2 在测试代码外部创建临时环境]
*** xref:15.adoc#_15_6_3_使用mocking和模拟器方法集成托管服务[15.6.3 使用mocking和模拟器方法集成托管]
*** xref:15.adoc#_15_6_4_集成没有本地支持的远程服务[15.6.4 集成没有本地支持的远程服务]
** xref:15.adoc#_15_7_完全远程集成测试[15.7 完全远程集成测试]
*** xref:15.adoc#_15_7_1_程序化创建临时集成测试环境[15.7.1 程序化创建临时集成测试环境]
*** xref:15.adoc#_15_7_2_使用共享环境进行测试[15.7.2 使用共享环境进行测试]
*** xref:15.adoc#_15_7_3_使用生产环境进行测试[15.7.3 使用生产环境进行测试]
** xref:15.adoc#_15_8_选择你的完全远程集成测试策略[15.8 选择你的完全远程集成测试策略]
** xref:15.adoc#_15_9_小结[15.9 小结]
* xref:16.adoc[第 16 章 部署事件驱动型微服务]
** xref:16.adoc#_16_1_微服务部署的原则[16.1 微服务部署的原则]
** xref:16.adoc#_16_2_微服务部署的架构组件[16.2 微服务部署的架构组件]
*** xref:16.adoc#_16_2_1_持续集成系统持续交付系统和持续部署系统[16.2.1 持续集成系统、持续交付系统和持续部署]
*** xref:16.adoc#_16_2_2_cms和商业硬件[16.2.2 CMS和商业硬件]
** xref:16.adoc#_16_3_基本的全站式部署模式[16.3 基本的全站式部署模式]
** xref:16.adoc#_16_4_滚动更新模式[16.4 滚动更新模式]
** xref:16.adoc#_16_5_破坏性的schema变更模式[16.5 破坏性的schema变更模式]
*** xref:16.adoc#_16_5_1_通过两个事件流达到最终迁移[16.5.1 通过两个事件流达到最终迁移]
*** xref:16.adoc#_16_5_2_同步迁移到新事件流[16.5.2 同步迁移到新事件流]
** xref:16.adoc#_16_6_蓝绿部署模式[16.6 蓝绿部署模式]
** xref:16.adoc#_16_7_小结[16.7 小结]
* xref:17.adoc[第 17 章 结论]
** xref:17.adoc#_17_1_通信层[17.1 通信层]
** xref:17.adoc#_17_2_业务领域和界限上下文[17.2 业务领域和界限上下文]
** xref:17.adoc#_17_3_可共享的工具和基础设施[17.3 可共享的工具和基础设施]
** xref:17.adoc#_17_4_结构化事件[17.4 结构化事件]
** xref:17.adoc#_17_5_数据解放和单一事实来源[17.5 数据解放和单一事实来源]
** xref:17.adoc#_17_6_微服务[17.6 微服务]
** xref:17.adoc#_17_7_微服务实现方案[17.7 微服务实现方案]
** xref:17.adoc#_17_8_测试[17.8 测试]
** xref:17.adoc#_17_9_部署[17.9 部署]
** xref:17.adoc#_17_10_结语[17.10 结语]
* xref:about_author.adoc[关于作者]
* xref:about_cover.adoc[关于封面]
